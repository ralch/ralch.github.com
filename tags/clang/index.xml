<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/tags/clang/index.xml</link>
    <language>en-us</language>
    <author>Svett Ralchev</author>

    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>

    <item>
      <title>Conditional compilation in Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-conditional-compilation/</link>
      <pubDate>Sun, 16 Aug 2015 08:40:35 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-conditional-compilation/</guid>
      <description>

&lt;p&gt;When developing Go package or application that depends on specific features
of the underlying platform or architecture it is often necessary
to use a specialised implementation.&lt;/p&gt;

&lt;p&gt;There are two parts of Go conditional compilation system, which we will now
explore in more detail.&lt;/p&gt;

&lt;h2 id=&#34;build-constraints&#34;&gt;Build constraints&lt;/h2&gt;

&lt;p&gt;A build constraints (known as build tags) is an optional top line comment that
starts with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build

package api
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declaration of build constraints follows the following rules:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Each tag is alphanumeric word&lt;/li&gt;
&lt;li&gt;Tag preceded by &lt;code&gt;!&lt;/code&gt; defines its negation.&lt;/li&gt;
&lt;li&gt;A build constraint is evaluated as the OR of space-separated options.&lt;/li&gt;
&lt;li&gt;Each option evaluates as the AND of its comma-separated terms.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That means if we have the following build constraint:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build linux,386 darwin,!cgo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will be evaluated by the compilation system as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(linux AND 386) OR (darwin AND (NOT cgo))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A file can have multiple build constraints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build linux freebsd
// +build 386

package api
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The evaluated constraint is a logical &lt;code&gt;AND&lt;/code&gt; of the individual build tags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(linux OR freebsd) AND 386
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that the build tags do not have strict validation. Be aware that they
should be formatted as the provided samples. In addition the last build tags should
be associated with a trailing new line. That makes it non-associated with any declaration.
Fortunately you can verify them by using &lt;code&gt;go vet&lt;/code&gt; tool.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;file-suffixes&#34;&gt;File suffixes&lt;/h2&gt;

&lt;p&gt;The second option for conditional compilation is the name of the
source file itself. This approach is simpler than build tags, and allows
the Go build system to exclude files without having to process the file.&lt;/p&gt;

&lt;p&gt;We should add one of the following suffixes to desired files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*_GOOS // operation system
*_GOARCH // platform architecture
*_GOOS_GOARCH // both combined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are all available architectures and operation system supported by Go
build system:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;GOOS&lt;/th&gt;
&lt;th&gt;GOARCH&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dragonfly&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dragonfly&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;plan9&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;plan9&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;solaris&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;windows&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;windows&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Examples for such a files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;container_windows.go // only builds on windows system
container_linux.go // only builds on linux system
container_freebsd_386.go // only builds on FreeBSD system with 386 architecture
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to exclude a file from compilation, you should use &lt;code&gt;ignore&lt;/code&gt; build
constraint:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build ignore

package api
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-files&#34;&gt;Test files&lt;/h3&gt;

&lt;p&gt;Test files also support build constraints and file suffixes. They behave in the same
manner as other Go source files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;container_windows_test.go // windows specific container tests
container_linux_test.go // linux specific container tests
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;experimenting-with-c-c-preprocessor-and-go&#34;&gt;Experimenting with C/C++ preprocessor and Go&lt;/h2&gt;

&lt;p&gt;Go does not have a preprocessor to control the inclusion of platform specific code.
Even though C preprocessor is intended to be used only with C, C++, and Objective-C source code,
we will use it as a general text processor of Go source code.&lt;/p&gt;

&lt;p&gt;Lets have the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: app.pgo
package main

import &amp;quot;fmt&amp;quot;
#ifdef PRINT_DATE
import &amp;quot;time&amp;quot;
#endif

func main() {
  fmt.Println(&amp;quot;Application is executed.&amp;quot;)
#ifdef PRINT_DATE
  fmt.Printf(&amp;quot;Current Date: %s\n&amp;quot;, time.Now().String())
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute the C preprocessor on &lt;code&gt;app.pgo&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// -P disable linemaker output.
$ cpp -P app.pgo app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will produce a new file &lt;code&gt;app.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: app.go
package main

import &amp;quot;fmt&amp;quot;

func main() {
  fmt.Println(&amp;quot;Application is executed.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we define &lt;code&gt;PRINT_DATE&lt;/code&gt; variable for the preprocessor by using &lt;code&gt;-D&lt;/code&gt; flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cpp -DPRINT_DATE -P app.pgo app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will produce a new file that includes additional print statment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: app.go
package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;time&amp;quot;

func main() {
  fmt.Println(&amp;quot;Application is executed.&amp;quot;)
  fmt.Printf(&amp;quot;Current Date: %s\n&amp;quot;, time.Now().String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can combine the preprocessor operation with go build step:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpp -DPRINT_DATE -P app.pgo app.go | go build app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;verdict&#34;&gt;Verdict&lt;/h2&gt;

&lt;p&gt;We should aim to develop and build our Go applications by following Go idioms.
If the source file targets a specific platform, we should choose file suffix
approach. Otherwise, if the source file is applicable for multiple platforms and
we want to exclude a specific feature or platform, we should use build constraints instead.&lt;/p&gt;
</description>
    </item>

  </channel>
</rss>
