<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/tags/builder/index.xml</link>
    <language>en-us</language>
    <author>Svetlin Ralchev</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Desing Patterns in Golang: Builder</title>
      <link>http://blog.ralch.com/tutorial/design-patterns/golang-builder/</link>
      <pubDate>Sun, 24 Jan 2016 08:46:53 UTC</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/design-patterns/golang-builder/</guid>
      <description>

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;The Builder Pattern is a creational design pattern that&amp;rsquo;s used to
encapsulate the construction logic for an object. It is often used
when the construction process of an object is complex. The patterns is well
suited for constructing different representations of the same class.&lt;/p&gt;

&lt;h4 id=&#34;purpose&#34;&gt;Purpose&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Separate the construction of a complex object from its representation so that
the same construction process can create different representations.&lt;/li&gt;
&lt;li&gt;A common software creational design pattern that&amp;rsquo;s used to encapsulate the
construction logic for an object.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;design-pattern-diagram&#34;&gt;Design Pattern Diagram&lt;/h4&gt;

&lt;p&gt;The Builder Pattern is comprised of four components: a builder interface, a
concrete builder, a director and a product.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/design-patterns/builder.gif&#34; alt=&#34;Builder Class Diagram&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Builder&lt;/code&gt; defines a template for the steps to construct the product.
Specifies an abstract interface for creating parts of a Product object.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Concrete Builder&lt;/code&gt; implements the builder interface and provides an interface
for getting the product. Constructs and assembles parts of the product by
implementing the Builder interface defines and keeps track of the
representation it creates provides an interface for retrieving the product.
&lt;code&gt;ConcreteBuilder&lt;/code&gt; builds the product&amp;rsquo;s internal representation and defines
the process by which it&amp;rsquo;s assembled includes classes that define the
constituent parts, including interfaces for assembling the parts into the
final result.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Director&lt;/code&gt; constructs the object through the builder interface.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Product&lt;/code&gt; is the main object that&amp;rsquo;s constructed. Represents the complex
object under construction.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;The Builder pattern separates the construction of a complex object from its
representation so that the same construction process can create different
representations. This pattern is used by mail service to construct
children&amp;rsquo;s mails to Santa Claus.&lt;/p&gt;

&lt;p&gt;Note that there can be variation in the content of the children&amp;rsquo;s emails, but the
construction process is the same. In the example, the service supports &lt;code&gt;JSON&lt;/code&gt;
and &lt;code&gt;XML&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The messages typically consist of body and format. They can be transmitted via
different protocol. In order to do that their body should be encoded in the right
format.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Message is the Product object in Builder Design Pattern
type Message struct {
	// Message Body
	Body []byte
	// Message Format
	Format string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every message body should consist the recipient and text. Therefore, the Builder
interface provides a functions to set these attributes. The &lt;code&gt;Message&lt;/code&gt; function
is responsible for constructing the actual message in the right format.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// MessageBuilder is the inteface that every concrete implementation
// should obey
type MessageBuilder interface {
	// Set the message&#39;s recipient
	SetRecipient(recipient string)
	// Set the message&#39;s text
	SetText(text string)
	// Returns the built Message
	Message() (*Message, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;JSONMessageBuilder&lt;/code&gt; is a concrete implementation of the &lt;code&gt;MessageBuilder&lt;/code&gt;
interface. It uses &lt;a href=&#34;http://golang.org/pkg/encoding/json/&#34;&gt;json&lt;/a&gt; package to
encode the message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// JSON Message Builder is concrete builder
type JSONMessageBuilder struct {
	messageRecipient string
	messageText      string
}

func (b *JSONMessageBuilder) SetRecipient(recipient string) {
	b.messageRecipient = recipient
}

func (b *JSONMessageBuilder) SetText(text string) {
	b.messageText = text
}

func (b *JSONMessageBuilder) Message() (*Message, error) {
	m := make(map[string]string)
	m[&amp;quot;recipient&amp;quot;] = b.messageRecipient
	m[&amp;quot;message&amp;quot;] = b.messageText

	data, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}

	return &amp;amp;Message{Body: data, Format: &amp;quot;JSON&amp;quot;}, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;XMLMessageBuilder&lt;/code&gt; is a concrete implementation of the &lt;code&gt;MessageBuilder&lt;/code&gt;
interface. It uses &lt;a href=&#34;http://golang.org/pkg/encoding/xml/&#34;&gt;xml&lt;/a&gt; package to encode
the message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// XML Message Builder is concrete builder
type XMLMessageBuilder struct {
	messageRecipient string
	messageText      string
}

func (b *XMLMessageBuilder) SetRecipient(recipient string) {
	b.messageRecipient = recipient
}

func (b *XMLMessageBuilder) SetText(text string) {
	b.messageText = text
}

func (b *XMLMessageBuilder) Message() (*Message, error) {
	type XMLMessage struct {
		Recipient string `xml:&amp;quot;recipient&amp;quot;`
		Text      string `xml:&amp;quot;body&amp;quot;`
	}

	m := XMLMessage{
		Recipient: b.messageRecipient,
		Text:      b.messageText,
	}

	data, err := xml.Marshal(m)
	if err != nil {
		return nil, err
	}

	return &amp;amp;Message{Body: data, Format: &amp;quot;XML&amp;quot;}, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sender object decides what should be the content of the email and its
recipient (ex. Santa Claus).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Sender is the Director in Builder Design Pattern
type Sender struct{}

// Build a concrete message via MessageBuilder
func (s *Sender) BuildMessage(builder MessageBuilder) (*Message, error) {
	builder.SetRecipient(&amp;quot;Santa Claus&amp;quot;)
	builder.SetText(&amp;quot;I have tried to be good all year and hope that you and your reindeers will be able to deliver me a nice present.&amp;quot;)
	return builder.Message()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should use the designed architecture to build XML and JSON messages in the
following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;sender := &amp;amp;messenger.Sender{}

jsonMsg, err := sender.BuildMessage(&amp;amp;messenger.JSONMessageBuilder{})
if err != nil {
	panic(err)
}

fmt.Println(string(jsonMsg.Body))

xmlMsg, err := sender.BuildMessage(&amp;amp;messenger.XMLMessageBuilder{})
if err != nil {
	panic(err)
}

fmt.Println(string(xmlMsg.Body))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;As you can see, the true strength of the Builder Pattern is that it lets you
break up the construction of a complex object. Not only that, it also allows
you to hide the construction process from the consumer, thus allowing for
additional representations of the product to be added with ease. The pattern
also encourages separation of concerns and promotes application extensibility&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
