<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/tags/compilation/index.xml</link>
    <language>en-us</language>
    <author>Svett Ralchev</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Sharing Golang packages to C and Go</title>
      <link>http://blog.ralch.com/tutorial/golang-sharing-libraries/</link>
      <pubDate>Sun, 23 Aug 2015 11:04:50 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-sharing-libraries/</guid>
      <description>

&lt;p&gt;The latest &lt;a href=&#34;https://blog.golang.org/go1.5&#34;&gt;Go 1.5&lt;/a&gt; version is out. As part of
the &lt;a href=&#34;https://golang.org/doc/go1.5&#34;&gt;new features&lt;/a&gt;, &lt;code&gt;Go compiler&lt;/code&gt; can compile
packages as a shared libraries.&lt;/p&gt;

&lt;p&gt;It accepts &lt;code&gt;-buildmode&lt;/code&gt; argument that determines how a package is compiled.
These are the following options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;archive&lt;/code&gt;: Build the listed non-main packages into .a files. Packages named
main are ignored.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c-archive&lt;/code&gt;: Build the listed main package, plus all packages it imports,
into a C archive file.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c-shared&lt;/code&gt;: Build the listed main packages, plus all packages that they import,
into C shared libraries.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shared&lt;/code&gt;: Combine all the listed non-main packages into a single shared library.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exe&lt;/code&gt;: Build the listed main packages and everything they import into executables.
Packages not named main are ignored.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By default, listed main packages are built into executables
and listed non-main packages are built into .a files.&lt;/p&gt;

&lt;p&gt;In this article we will explore two major ways to share libraries between Go and C:&lt;/p&gt;

&lt;h2 id=&#34;using-shared-library-in-go&#34;&gt;Using shared library in Go&lt;/h2&gt;

&lt;p&gt;Assume that &lt;code&gt;GOPATH&lt;/code&gt; contains this structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── calc
│   └── calc.go
└── cashier
    └── main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;calc&lt;/code&gt; package contains a set of functions that do arithmetic opertaions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: calc.go
package calc

func Sum(x, y int) int {
    return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before compile any shared library, the standard builtin packages should be installed
as shared library. This will allow any other shared library to link with them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go install -buildmode=shared -linkshared std
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the &lt;code&gt;calc&lt;/code&gt; package can be compiled as shared library linked to &lt;code&gt;std&lt;/code&gt; libraries:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go install -buildmode=shared -linkshared calc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Due to a &lt;a href=&#34;https://github.com/golang/go/issues/12236&#34;&gt;issue&lt;/a&gt;, building and installing
shared library should be from &lt;code&gt;$GOPATH/src&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Lets use the shared library &lt;code&gt;calc&lt;/code&gt; in the &lt;code&gt;cashier&lt;/code&gt; application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// package: cashier
// filename: main.go
package main

import &amp;quot;calc&amp;quot;
import &amp;quot;fmt&amp;quot;

func main() {
  fmt.Println(&amp;quot;Cashier Application&amp;quot;)
    fmt.Printf(&amp;quot;Result: %d\n&amp;quot;, calc.Sum(5, 10))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The application should be compiled and linked with &lt;code&gt;calc&lt;/code&gt; library
with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go build -linkshared -o app cashier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output of executing the application is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./app
Cashier Application
Result: 15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that this feature is available on &lt;code&gt;linux/amd64&lt;/code&gt; platform or when &lt;code&gt;gccgo&lt;/code&gt;
compiler is used.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;using-shared-go-library-in-c&#34;&gt;Using shared Go library in C&lt;/h2&gt;

&lt;p&gt;Go functions can be executed from C applications. They should be
exported by using the following comment line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//export &amp;lt;your_function_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code snippet below, the function &lt;code&gt;SayHello&lt;/code&gt; and &lt;code&gt;SayBye&lt;/code&gt; are exported:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// package name: nautilus
package main

import &amp;quot;C&amp;quot;
import &amp;quot;fmt&amp;quot;

//export SayHello
func SayHello(name string) {
	fmt.Printf(&amp;quot;Nautilus says: Hello, %s!\n&amp;quot;, name)
}

//export SayBye
func SayBye() {
	fmt.Println(&amp;quot;Nautilus says: Bye!&amp;quot;)
}

func main() {
	// We need the main function to make possible
	// CGO compiler to compile the package as C shared library
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The packaged should be compiled with &lt;code&gt;buildmode&lt;/code&gt; flags &lt;code&gt;c-shared&lt;/code&gt; or &lt;code&gt;c-archive&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// as c-shared library
$ go build -buildmode=c-shared -o nautilus.a nautilus.go
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// as c-archive 
$ go build -buildmode=c-archive -o nautilus.a nautilus.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As result the &lt;code&gt;GO&lt;/code&gt; compiler will produce a static/dynamic &lt;code&gt;C&lt;/code&gt; library &lt;code&gt;nautilus.a&lt;/code&gt; and
header file &lt;code&gt;nautilus.h&lt;/code&gt;. The header file contains type definitions that marshall
and unmarshall data between &lt;code&gt;Go&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef __SIZE_TYPE__ GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
typedef __complex float GoComplex64;
typedef __complex double GoComplex128;
typedef struct { char *p; GoInt n; } GoString;
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif


extern void SayHello(GoString p0);

extern void SayBye();

#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The header file &lt;code&gt;nautilus.h&lt;/code&gt; shoulde be imported from every &lt;code&gt;C&lt;/code&gt; application
that executed &lt;code&gt;SayHello&lt;/code&gt; and &lt;code&gt;SayBye&lt;/code&gt; functions.&lt;/p&gt;

&lt;p&gt;In the example below, the &lt;code&gt;SayHello&lt;/code&gt; function is called with parameter of type
&lt;code&gt;GoString&lt;/code&gt;. It includes &lt;code&gt;char*&lt;/code&gt; field and its length.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: _wale.c
#include &amp;quot;nautilus.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;

int main() {
  printf(&amp;quot;This is a C Application.\n&amp;quot;);
  GoString name = {&amp;quot;Jack&amp;quot;, 4};
  SayHello(name);
  SayBye();
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;_wale.c&lt;/code&gt; file is compiled with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -o _wale _wale.c nautilus.a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execution produce the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./wale
This is a C Application.
Nautilus says: Hello, Jack!
Nautilus says: Bye!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Sharing libraries between &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;Go&lt;/code&gt; gives opportunity to build greater and better
application by using the best from both worlds. This provides to a legacy system
a modern language that can improve their maintainance costs and business needs.
It maximize code reusability in the &lt;code&gt;Go&lt;/code&gt; ecosystem.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Conditional compilation in Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-conditional-compilation/</link>
      <pubDate>Sun, 16 Aug 2015 08:40:35 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-conditional-compilation/</guid>
      <description>

&lt;p&gt;When developing Go package or application that depends on specific features
of the underlying platform or architecture it is often necessary
to use a specialised implementation.&lt;/p&gt;

&lt;p&gt;There are two parts of Go conditional compilation system, which we will now
explore in more detail.&lt;/p&gt;

&lt;h2 id=&#34;build-constraints&#34;&gt;Build constraints&lt;/h2&gt;

&lt;p&gt;A build constraints (known as build tags) is an optional top line comment that
starts with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build

package api 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declaration of build constraints follows the following rules:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Each tag is alphanumeric word&lt;/li&gt;
&lt;li&gt;Tag preceded by &lt;code&gt;!&lt;/code&gt; defines its negation.&lt;/li&gt;
&lt;li&gt;A build constraint is evaluated as the OR of space-separated options.&lt;/li&gt;
&lt;li&gt;Each option evaluates as the AND of its comma-separated terms.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That means if we have the following build constraint:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build linux,386 darwin,!cgo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will be evaluated by the compilation system as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(linux AND 386) OR (darwin AND (NOT cgo))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A file can have multiple build constraints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build linux freebsd
// +build 386

package api
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The evaluated constraint is a logical &lt;code&gt;AND&lt;/code&gt; of the individual build tags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(linux OR freebsd) AND 386
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that the build tags do not have strict validation. Be aware that they
should be formatted as the provided samples. In addition the last build tags should
be associated with a trailing new line. That makes it non-associated with any declaration.
Fortunately you can verify them by using &lt;code&gt;go vet&lt;/code&gt; tool.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;file-suffixes&#34;&gt;File suffixes&lt;/h2&gt;

&lt;p&gt;The second option for conditional compilation is the name of the
source file itself. This approach is simpler than build tags, and allows
the Go build system to exclude files without having to process the file.&lt;/p&gt;

&lt;p&gt;We should add one of the following suffixes to desired files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*_GOOS // operation system
*_GOARCH // platform architecture
*_GOOS_GOARCH // both combined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are all available architectures and operation system supported by Go
build system:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;GOOS&lt;/th&gt;
&lt;th&gt;GOARCH&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dragonfly&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dragonfly&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;plan9&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;plan9&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;solaris&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;windows&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;windows&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Examples for such a files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;container_windows.go // only builds on windows system
container_linux.go // only builds on linux system
container_freebsd_386.go // only builds on FreeBSD system with 386 architecture
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to exclude a file from compilation, you should use &lt;code&gt;ignore&lt;/code&gt; build
constraint:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build ignore

package api
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-files&#34;&gt;Test files&lt;/h3&gt;

&lt;p&gt;Test files also support build constraints and file suffixes. They behave in the same
manner as other Go source files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;container_windows_test.go // windows specific container tests
container_linux_test.go // linux specific container tests
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;experimenting-with-c-c-preprocessor-and-go&#34;&gt;Experimenting with C/C++ preprocessor and Go&lt;/h2&gt;

&lt;p&gt;Go does not have a preprocessor to control the inclusion of platform specific code.
Even though C preprocessor is intended to be used only with C, C++, and Objective-C source code,
we will use it as a general text processor of Go source code.&lt;/p&gt;

&lt;p&gt;Lets have the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: app.pgo
package main

import &amp;quot;fmt&amp;quot;
#ifdef PRINT_DATE
import &amp;quot;time&amp;quot;
#endif

func main() {
  fmt.Println(&amp;quot;Application is executed.&amp;quot;)
#ifdef PRINT_DATE
  fmt.Printf(&amp;quot;Current Date: %s\n&amp;quot;, time.Now().String())
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute the C preprocessor on &lt;code&gt;app.pgo&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// -P disable linemaker output.
$ cpp -P app.pgo app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will produce a new file &lt;code&gt;app.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: app.go
package main

import &amp;quot;fmt&amp;quot;

func main() {
  fmt.Println(&amp;quot;Application is executed.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we define &lt;code&gt;PRINT_DATE&lt;/code&gt; variable for the preprocessor by using &lt;code&gt;-D&lt;/code&gt; flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cpp -DPRINT_DATE -P app.pgo app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will produce a new file that includes additional print statment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: app.go
package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;time&amp;quot;

func main() {
  fmt.Println(&amp;quot;Application is executed.&amp;quot;)
  fmt.Printf(&amp;quot;Current Date: %s\n&amp;quot;, time.Now().String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can combine the preprocessor operation with go build step:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpp -DPRINT_DATE -P app.pgo app.go | go build app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;verdict&#34;&gt;Verdict&lt;/h2&gt;

&lt;p&gt;We should aim to develop and build our Go applications by following Go idioms.
If the source file targets a specific platform, we should choose file suffix
approach. Otherwise, if the source file is applicable for multiple platforms and
we want to exclude a specific feature or platform, we should use build constraints instead.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
