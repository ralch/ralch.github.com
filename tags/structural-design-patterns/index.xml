<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/tags/structural-design-patterns/index.xml</link>
    <language>en-us</language>
    <author>Svett Ralchev</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Design Patterns in Golang: Decorator</title>
      <link>http://blog.ralch.com/tutorial/design-patterns/golang-decorator/</link>
      <pubDate>Sun, 17 Apr 2016 18:33:52 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/design-patterns/golang-decorator/</guid>
      <description>

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;The Decorator pattern adds new functionality to an existing object
without altering its structure. It is a structural pattern as this pattern acts
as a wrapper to existing class.&lt;/p&gt;

&lt;p&gt;The instanciate a decorator struct which decorates (wraps) the original object
and provides additional functionality keeping its methods signature intact.&lt;/p&gt;

&lt;h4 id=&#34;purpose&#34;&gt;Purpose&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Attach additional responsibilities to an object dynamically.&lt;/li&gt;
&lt;li&gt;Decorators provide a flexible alternative to inheritance for extending
functionality.&lt;/li&gt;
&lt;li&gt;Wrapping a present, putting it in a box, and wrapping the box.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;design-pattern-diagram&#34;&gt;Design Pattern Diagram&lt;/h4&gt;

&lt;p&gt;The Decorator Pattern has the following entities:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/design-patterns/decorator.gif&#34; alt=&#34;Decorator Class Diagram&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Component&lt;/code&gt; defines the interface for objects that can have responsibilities added to them dynamically.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteComponent&lt;/code&gt; defines an object to which additional responsibilities can be attached.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Decorator&lt;/code&gt; maintains a reference to a Component object and defines an interface that conforms to Component&amp;rsquo;s interface.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteDecorator&lt;/code&gt; adds responsibilities to the component.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;We are explore the use of decorator pattern via following example in
which we will extend an existing object that fetches a data from web service.
We will decorate it by adding circuit breaker capabilities without changing the
struct interface.&lt;/p&gt;

&lt;p&gt;Lets have a &lt;code&gt;Fetcher&lt;/code&gt; interface that defines a contract for fetching some data
from different sources.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Args of fetching function
type Args map[string]string

// Data returned by fetch
type Data map[string]string

// Fetcher fetches a data from remote endpoint
type Fetcher interface {
	// Fetch fetches the data
	Fetch(args Args) (Data, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A concrete implementation of the &lt;code&gt;Fetcher&lt;/code&gt; interface is the &lt;code&gt;Repository&lt;/code&gt; struct
which provides some dummy data if the provided arguments are not empty, otherwise
returns an error. The &lt;code&gt;Repository&lt;/code&gt; struct is a concrete component in the context
of The Decorator Pattern.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Repository of data
type Repository struct{}

// Fetch fetches data
func (r *Repository) Fetch(args Args) (Data, error) {
	if len(args) == 0 {
		return Data{}, fmt.Errorf(&amp;quot;No arguments are provided&amp;quot;)
	}

	data := Data{
		&amp;quot;user&amp;quot;:     &amp;quot;root&amp;quot;,
		&amp;quot;password&amp;quot;: &amp;quot;swordfish&amp;quot;,
	}
	fmt.Printf(&amp;quot;Repository fetched data successfully: %v\n&amp;quot;, data)
	return data, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;Retrier&lt;/code&gt; struct is the decorator that adds circuit breaker capabilities to
any component that implements the &lt;code&gt;Fetcher&lt;/code&gt; interface. The &lt;code&gt;Retrier&lt;/code&gt; has a few
properties that allow that. The &lt;code&gt;RetryCount&lt;/code&gt; property defines the number of times
that the retrier should try to fetch if there is an error. The &lt;code&gt;WaitInterval&lt;/code&gt;
property defines the interval between every retry. The &lt;code&gt;Fetcher&lt;/code&gt; property is
points to the object that is decorated. The &lt;code&gt;Retrier&lt;/code&gt; calls the &lt;code&gt;Fetch&lt;/code&gt;
function of the decorated object until it succeeds or exceed the retry policy.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Retrier retries multiple times
type Retrier struct {
	RetryCount   int
	WaitInterval time.Duration
	Fetcher      Fetcher
}

// Fetch fetches data
func (r *Retrier) Fetch(args Args) (Data, error) {
	for retry := 1; retry &amp;lt;= r.RetryCount; retry++ {
		fmt.Printf(&amp;quot;Retrier retries to fetch for %d\n&amp;quot;, retry)
		if data, err := r.Fetcher.Fetch(args); err == nil {
			fmt.Printf(&amp;quot;Retrier fetched for %d\n&amp;quot;, retry)
			return data, nil
		} else if retry == r.RetryCount {
			fmt.Printf(&amp;quot;Retrier failed to fetch for %d times\n&amp;quot;, retry)
			return Data{}, err
		}
		fmt.Printf(&amp;quot;Retrier is waiting after error fetch for %v\n&amp;quot;, r.WaitInterval)
		time.Sleep(r.WaitInterval)
	}

	return Data{}, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can add the new retry capabilities by wrapping the &lt;code&gt;Repository&lt;/code&gt; instance
with the &lt;code&gt;Retrier&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;repository := &amp;amp;cbreaker.Repository{}
retrier := &amp;amp;cbreaker.Retrier{
	RetryCount:   5,
	WaitInterval: time.Second,
	Fetcher:      repository,
}

data, err := repository.Fetch(cbreaker.Args{&amp;quot;id&amp;quot;: &amp;quot;1&amp;quot;})
fmt.Printf(&amp;quot;#1 repository.Fetch: %v\n&amp;quot;, data)

data, err = retrier.Fetch(cbreaker.Args{})
fmt.Printf(&amp;quot;#2 retrier.Fetch error: %v\n&amp;quot;, err)

data, err = retrier.Fetch(cbreaker.Args{&amp;quot;id&amp;quot;: &amp;quot;1&amp;quot;})
fmt.Printf(&amp;quot;#3 retrier.Fetch: %v\n&amp;quot;, data)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;The Decorator Pattern is more convenient for adding functionalities to objects
instead of entire structs at runtime. With decoration it is also possible to
remove the added functionalities dynamically.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Patterns in Golang: Composite</title>
      <link>http://blog.ralch.com/tutorial/design-patterns/golang-composite/</link>
      <pubDate>Thu, 31 Mar 2016 09:00:27 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/design-patterns/golang-composite/</guid>
      <description>

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;A Composite Design Pattern is a structural pattern that uses to employ
composition when implementing an interface rather than using multiple
inheritance. It composes objects into tree structures and lets
clients treat individual objects and compositions uniformly.&lt;/p&gt;

&lt;p&gt;There are situations when clients ignore the difference between
compositions of objects and individual objects. If dealing with multiple
objects in the same way as handle each of deam is identical, the Composite
Design pattern is a good choice to decrease the complexity and treat them as
homogeneous.&lt;/p&gt;

&lt;h4 id=&#34;purpose&#34;&gt;Purpose&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;The intent of this pattern is to compose objects into tree structures to
represent part-whole hierarchies.&lt;/li&gt;
&lt;li&gt;Composite lets clients treat individual objects and compositions of objects
uniformly.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;design-pattern-diagram&#34;&gt;Design Pattern Diagram&lt;/h4&gt;

&lt;p&gt;The Composite Pattern provides the following units: Component, Leaf and
Composite.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/design-patterns/composite.gif&#34; alt=&#34;Composite Class Diagram&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Component&lt;/code&gt; is an interface for all components, including composite ones. It declares the interface for objects in the composition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Leaf&lt;/code&gt; represents leaf objects in the composition implements all &lt;code&gt;Component&lt;/code&gt; methods&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Composite&lt;/code&gt; represents a composite &lt;code&gt;Component&lt;/code&gt; that has children. Usually
implements all Componenet methods and methods to manipulate children.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;The Composite Design Pattern is very common approach for implementing a
document object model hierarchy. Such an example are image editors, which
compose different shapes and layers into hierarchy.&lt;/p&gt;

&lt;p&gt;Lets implement a basic architecture of such an editor. Lets use the following
interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// VisualElement that is drawn on the screen
type VisualElement interface {
	// Draw draws the visual element
	Draw(drawer *Drawer) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The editor supports two kind of shapes (circle and square). Each of the structs
that represents the coresponding shape obeys the &lt;code&gt;VisualElement&lt;/code&gt; interface by
implementing a &lt;code&gt;Draw&lt;/code&gt; function that has exactly the same signiture exposed in
the interface. The following code snippet illustrate the implementation of
thoes components:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Square represents a square
type Square struct {
	// Location of the square
	Location Point
	// Side size
	Side float64
}

// Draw draws a square
func (square *Square) Draw(drawer *Drawer) error {
	return drawer.DrawRect(Rect{
		Location: square.Location,
		Size: Size{
			Height: square.Side,
			Width:  square.Side,
		},
	})
}

// Circle represents a circle shape
type Circle struct {
	// Center of the circle
	Center Point
	// Radius of the circle
	Radius float64
}

// Draw draws a circle
func (circle *Circle) Draw(drawer *Drawer) error {
	rect := Rect{
		Location: Point{
			X: circle.Center.X - circle.Radius,
			Y: circle.Center.Y - circle.Radius,
		},
		Size: Size{
			Width:  2 * circle.Radius,
			Height: 2 * circle.Radius,
		},
	}

	return drawer.DrawEllipseInRect(rect)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to allow composition and drawing of multiple shapes on the screen, a
&lt;code&gt;Layer&lt;/code&gt; compose thoes object. It contains an array of &lt;code&gt;VisualElement&lt;/code&gt;. It is
responsible to interate over the elements and draw each of them. As you can see
the actual struct uses the &lt;code&gt;VisualElement&lt;/code&gt; interface as a contract to support
different shapes no matter what is their type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Layer contains composition of visual elements
type Layer struct {
	// Elements of visual elements
	Elements []VisualElement
}

// Draw draws a layer
func (layer *Layer) Draw(drawer *Drawer) error {
	for _, element := range layer.Elements {
		if err := element.Draw(drawer); err != nil {
			return err
		}
		fmt.Println()
	}

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The object can be composed as it is shown in the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;circle := &amp;amp;photoshop.Circle{
	Center: photoshop.Point{X: 100, Y: 100},
	Radius: 50,
}

square := &amp;amp;photoshop.Square{
	Location: photoshop.Point{X: 50, Y: 50},
	Side:     20,
}

layer := &amp;amp;photoshop.Layer{
	Elements: []photoshop.VisualElement{
		circle,
		square,
	},
}

layer.Draw(&amp;amp;photoshop.Drawer{})
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;Dealing with Tree-structured data makes code more complex, and therefore,
error prone. The Composite Design Patterns provides a solution that allows
treating complex and primitive objects uniformly. The operations you can
perform on all the composite objects often have a least common relationship
that allows handling a set of object as a single unit.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Patterns in Golang: Adapter</title>
      <link>http://blog.ralch.com/tutorial/design-patterns/golang-adapter/</link>
      <pubDate>Mon, 22 Feb 2016 08:42:38 UTC</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/design-patterns/golang-adapter/</guid>
      <description>

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;The Adapter Pattern&lt;/code&gt; is responsible for adaptation of two incompatible
interfaces. It is a structural pattern that is responsible to join
functionalities of independent or incompatible interfaces without modifing
their implementation.&lt;/p&gt;

&lt;p&gt;Interfaces may be incompatible but the inner functionality should suit the
need. It allows otherwise incompatible objects to work together by converting
the interface of each struct into an interface expected by the clients.&lt;/p&gt;

&lt;h4 id=&#34;purpose&#34;&gt;Purpose&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Impedance match an old component to a new system&lt;/li&gt;
&lt;li&gt;Wrap the interface of a object into another interface clients expect.&lt;/li&gt;
&lt;li&gt;Adapter lets objects work together, that could not otherwise because of incompatible interfaces.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;design-pattern-diagram&#34;&gt;Design Pattern Diagram&lt;/h4&gt;

&lt;p&gt;The structs/objects that are participating in adapter pattern are illustrated
in the following diagram:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/design-patterns/adapter.gif&#34; alt=&#34;Adapter Class Diagram&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Target&lt;/code&gt; is the domain-specific interface that Client wants to use.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Adapter&lt;/code&gt; adapts the interface &lt;code&gt;Adaptee&lt;/code&gt; to the &lt;code&gt;Target&lt;/code&gt; interface. It
implements the &lt;code&gt;Target&lt;/code&gt; interface in terms of the Adaptee.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Adaptee&lt;/code&gt; defines an existing interface that needs adapting.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt; collaborates with objects conforming to the &lt;code&gt;Target&lt;/code&gt; interface.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;Target&lt;/code&gt; interface enables objects of adaptee types to be interchangeable
with any other objects that might implement the same interface. However, the
adaptees might not conform to the &lt;code&gt;Target&lt;/code&gt;. The interface alone is not a
sufficiently powerful mechanism. We need the Adapter pattern. An &lt;code&gt;Adaptee&lt;/code&gt;
offers similar functionality to the client, but under a different name and with
possibly different parameters. The &lt;code&gt;Adaptee&lt;/code&gt; is completely independent of the
other classes and is oblivious to any naming conventions or signatures that
they have.&lt;/p&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;Lets explore how we should use the Adapter Design Pattern to adopt two
incompatible payment systems and make them available for our customers. Assume
that we are building system that should support &lt;code&gt;PayPal&lt;/code&gt; and &lt;code&gt;Bank&lt;/code&gt; payments.
In addition, we are consuming two external libraries that handles each of this
payment methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;package paypal

import (
	&amp;quot;errors&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;regexp&amp;quot;
)

var mailRegexp = regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,4}$`)

// Money of PayPal transactions
type Money struct {
	// Amount
	Amount float64
	// Currency for that amount
	Currency string
}

// Payment in PayPal
type Payment struct {
	// APIKey is the PayPal API key
	APIKey string
}

// Send money
func (*Payment) Send(senderEmail, recipientEmail string, money *Money) error {
	if !mailRegexp.MatchString(senderEmail) {
		return errors.New(&amp;quot;Invalid sender email address&amp;quot;)
	}

	if !mailRegexp.MatchString(recipientEmail) {
		return errors.New(&amp;quot;Invalid recipient email address&amp;quot;)
	}

	if money == nil {
		return errors.New(&amp;quot;The money must be provided&amp;quot;)
	}

	if money.Amount &amp;lt;= 0 {
		return errors.New(&amp;quot;The amount cannot be negative&amp;quot;)
	}

	if money.Currency == &amp;quot;&amp;quot; {
		return errors.New(&amp;quot;The currency must be provided&amp;quot;)
	}

	fmt.Printf(&amp;quot;Send %f %s from %s to %s&amp;quot;, money.Amount, money.Currency, senderEmail, recipientEmail)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;package bank

import (
	&amp;quot;errors&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

// AccountType determines the type of bank account
type AccountType uint8

const (
	// AccountTypeCurrent is a current bank account
	AccountTypeCurrent AccountType = iota
	// AccountTypeSaving is a saving bank account
	AccountTypeSaving
)

// Account is a bank account
type Account struct {
	// Owner is the bank account owner
	Owner string
	// Email of the owner
	Email string
	// Balance is the bank account balance
	Balance float64
	// Currency of the account
	Currency string
}

// Transaction is the bank transaction
type Transaction struct {
	FromAccount *Account
	ToAccount   *Account
	Amount      float64
	Date        time.Time
	Reason      string
}

// Gateway for the Bank
type Gateway struct {
	// Token Key
	Token string
	// Accounts
	Accounts []*Account
}

// FindAccountByEmail finds a bank account
func (g *Gateway) FindAccountByEmail(email string) (*Account, error) {
	for _, account := range g.Accounts {
		if account.Email == email {
			return account, nil
		}
	}
	return nil, errors.New(&amp;quot;Account Not Found&amp;quot;)
}

// ProcessTransaction processes a bank transaction
func (g *Gateway) ProcessTransaction(t *Transaction) error {
	if t.FromAccount == nil {
		return errors.New(&amp;quot;FromAccount is missing&amp;quot;)
	}
	if t.ToAccount == nil {
		return errors.New(&amp;quot;ToAccount is missing&amp;quot;)
	}

	if t.Reason == &amp;quot;&amp;quot; {
		return errors.New(&amp;quot;Reason is not provided&amp;quot;)
	}

	if t.Amount &amp;lt;= 0 {
		return errors.New(&amp;quot;Invalid amount&amp;quot;)
	}

	if t.Amount &amp;gt; t.FromAccount.Balance {
		return errors.New(&amp;quot;Insufficient funds&amp;quot;)
	}

	fmt.Printf(&amp;quot;Transfered %f %s from %s to %s at %v&amp;quot;, t.Amount,
		t.FromAccount.Currency, t.FromAccount.Owner, t.ToAccount.Owner, t.Date)

	t.FromAccount.Balance -= t.Amount
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are developing a shopping card that should work with different payment methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Checkouter checkouts order
type Payment interface {
	// Pay from email to email this amount
	Pay(fromEmail, toEmail string, amount float64) error
}

// Item in the shopping card
type Item struct {
	// Name of the item
	Name string
	// Price of the item
	Price float64
}

// ShoppingCard in online store
type ShoppingCard struct {
	// Items im the ShoppingCard
	Items []*Item
	// PaymentMethod selected
	PaymentMethod Payment
	// ShopEmailAddress address of the shop
	ShopEmailAddress string
}

// Checkout checkouts a shopping card
func (c *ShoppingCard) Checkout(payeeEmail string) error {
	var total float64

	for _, item := range c.Items {
		total += item.Price
	}

	return c.PaymentMethod.Pay(payeeEmail, c.ShopEmailAddress, total)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you might see, the Bank API and PayPal API cannot be used as different
payment options in the &lt;code&gt;ShoppingCard&lt;/code&gt; object due to their different signatures.&lt;/p&gt;

&lt;p&gt;In order to adopt them we should implement an adapters that obey the &lt;code&gt;Payment&lt;/code&gt;
interface.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;BankAdapter&lt;/code&gt; adapts the bank package API by wrapping &lt;code&gt;bank.Gateway&lt;/code&gt;
struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// BankAdapter adapts bank API
type BankAdapter struct {
	// Gateway of the bank
	Gateway *bank.Gateway
}

// Pay from email to email this amount
func (b *BankAdapter) Pay(fromEmail, toEmail string, amount float64) error {
	fromAccount, err := b.Gateway.FindAccountByEmail(fromEmail)
	if err != nil {
		return err
	}

	toAccount, err := b.Gateway.FindAccountByEmail(toEmail)
	if err != nil {
		return err
	}

	t := &amp;amp;bank.Transaction{
		FromAccount: fromAccount,
		ToAccount:   toAccount,
		Amount:      amount,
		Date:        time.Now(),
		Reason:      &amp;quot;Payment to Online Store&amp;quot;,
	}

	return b.Gateway.ProcessTransaction(t)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;PayPal&lt;/code&gt; API is adopted by &lt;code&gt;PayPalAdapter&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// PayPalAdapter adapts PayPal API
type PayPalAdapter struct {
	Payment *paypal.Payment
}

// Pay from email to email this amount
func (p *PayPalAdapter) Pay(fromEmail, toEmail string, amount float64) error {
	return p.Payment.Send(fromEmail, toEmail, &amp;amp;paypal.Money{Amount: amount, Currency: &amp;quot;USD&amp;quot;})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;The Adapter Pattern&lt;/code&gt; is used wherever there is code to be wrapped up and
redirected to a different implementation.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;But How Much the &lt;code&gt;Adapter&lt;/code&gt; Should Do?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If the &lt;code&gt;Target&lt;/code&gt; and &lt;code&gt;Adaptee&lt;/code&gt; has similarities then the adapter has just to
delegate the requests from the Target to the Adaptee. If &lt;code&gt;Target&lt;/code&gt; and &lt;code&gt;Adaptee&lt;/code&gt;
are not similar, then the adapter might have to convert the data structures
between those and to implement the operations required by the Target but not
implemented by the Adaptee.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
