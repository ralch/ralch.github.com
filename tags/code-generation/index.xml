<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/tags/code-generation/index.xml</link>
    <language>en-us</language>
    <author>Svett Ralchev</author>

    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>

    <item>
      <title>Develop code generation tool for Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-code-generation-tool-implementation/</link>
      <pubDate>Sat, 31 Oct 2015 08:41:39 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-code-generation-tool-implementation/</guid>
      <description>

&lt;p&gt;In my previous blog post, we discussed one of my favourite code generation tools
for Go. We found that they can be used to automate our trivial development tasks
or even introduce features like generics and queries. Lets explore how to
create our own tool.&lt;/p&gt;

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;The Go generate subcommand is a program that scans for special comments in your
Go source code. The comment declares a command that should be executed. The
tools is not part of Go build toolbelt. Usually it&amp;rsquo;s used by packaged
developers.&lt;/p&gt;

&lt;p&gt;This is the format of &lt;code&gt;go:generate&lt;/code&gt; comments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate &amp;lt;subcommand&amp;gt; &amp;lt;arguments&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After identifying all &lt;code&gt;go:generate&lt;/code&gt; comments it will execute the specified
commands.&lt;/p&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;We will build a command line tool that generates an implementation of
&lt;a href=&#34;https://golang.org/pkg/io/#WriterTo&#34;&gt;io.WriterTo&lt;/a&gt; interface for concrete type
and format.&lt;/p&gt;

&lt;p&gt;Lets name the tool &lt;code&gt;wordsmith&lt;/code&gt;. Note that in the sample we will use only &lt;code&gt;json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;io.WriterTo&lt;/code&gt; provides a function that writes data to a writer. The return value
n is the number of bytes written. Any error encountered during the write is
also returned:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type WriterTo interface {
        WriteTo(w Writer) (n int64, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets have a Point struct that is annotated with special &lt;code&gt;go:generate&lt;/code&gt; comment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Point struct {
	X float64
	Y float64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we implement the funcationality manually, we should end up with the following
code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (obj Point) WriteTo(writer io.Writer) (int64, error) {
	data, err := json.Marshal(&amp;amp;obj)
	if err != nil {
		return 0, err
	}
	length, err := writer.Write(data)
	return int64(length), err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can trainsform it into a &lt;code&gt;text/template&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package {{ .PackageName }}

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;io&amp;quot;
)

func ({{ .Object }} {{ .Type }}) WriteTo(writer io.Writer) (int64, error) {
  data, err := json.Marshal({{ .MarshalObject }})
  if err != nil {
  	return 0, err
  }
  length, err := writer.Write(data)
  return int64(length), err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;wordsmith&lt;/code&gt; generation tools is a command line application that has the
following arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pointer&lt;/code&gt; determines whether a type is a pointer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt; defines the name of the type that implements &lt;code&gt;io.WriterTo&lt;/code&gt; interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package&lt;/code&gt; defines the package that contains this type&lt;/li&gt;
&lt;li&gt;&lt;code&gt;format&lt;/code&gt; defines the serialization format that &lt;code&gt;io.WriterTo&lt;/code&gt; is providing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The function initial reads the arguments, locates the package directory and
creates the output file in the following format &lt;code&gt;&amp;lt;type_name&amp;gt;_writer.go&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	typePointer := flag.Bool(&amp;quot;pointer&amp;quot;, false, &amp;quot;Determines whether a type is a pointer or not&amp;quot;)
	typeName := flag.String(&amp;quot;type&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Type that hosts io.WriterTo interface implementation&amp;quot;)
	packageName := flag.String(&amp;quot;package&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Package name&amp;quot;)
	format := flag.String(&amp;quot;format&amp;quot;, &amp;quot;json&amp;quot;, &amp;quot;Encoding format&amp;quot;)

	flag.Parse()

	if *typeName == &amp;quot;&amp;quot; || *format != &amp;quot;json&amp;quot; {
		flag.Usage()
		return
	}

	pkgDir, err := packageDir(*packageName)
	if err != nil {
		panic(err)
	}

	outputFile := formatFileName(*typeName)
	writer, err := os.Create(filepath.Join(pkgDir, outputFile))
	if err != nil {
		panic(err)
	}
	defer writer.Close()

	generator := &amp;amp;Generator{Format: JSON}

	m := metadata(*typeName, *typePointer, pkgDir)
	if err := generator.Generate(writer, m); err != nil {
		panic(err)
	}

	fmt.Printf(&amp;quot;Generated %s %s\n&amp;quot;, *format, outputFile)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;wordsmith.Generator&lt;/code&gt; type is responsible to execute the text template and
generate the output file. It instaciates text template object from the template
file and substitute it with the &lt;code&gt;Metadata&lt;/code&gt; object properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Metadata struct {
	PackageName   string
	Object        string
	MarshalObject string
	Type          string
}

type Generator struct {
	Format Format
}

func (g *Generator) Generate(writer io.Writer, metadata Metadata) error {
	tmpl, err := g.template()
	if err != nil {
		return nil
	}

	return tmpl.Execute(writer, metadata)
}

func (g *Generator) template() (*template.Template, error) {
	if g.Format != JSON {
		return nil, errors.New(&amp;quot;Unsupported format&amp;quot;)
	}

	resource, err := Asset(&amp;quot;templates/writeto_json.tmpl&amp;quot;)
	if err != nil {
		return nil, err
	}

	tmpl := template.New(&amp;quot;template&amp;quot;)
	return tmpl.Parse(string(resource))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can read more about text templates in &lt;a href=&#34;https://golang.org/pkg/text/template/&#34;&gt;the official golang
documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;wordsmith&lt;/code&gt; can be used from command line prompt or by annotating &lt;code&gt;Point&lt;/code&gt;
struct with the following comment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate wordsmith -type=Point -format=json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following command identifies the &lt;code&gt;go:generate comment&lt;/code&gt; and executes
declared &lt;code&gt;wordsmith&lt;/code&gt; submcommand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// it scans all
$ go generate ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use the download the full source code from &lt;a href=&#34;http://github.com/svett/wordsmith&#34;&gt;github&lt;/a&gt;
or install it immediatelly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/svett/wordsmith
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;I am looking forward to see more tools in the Go ecosystem. Hopefully this
blog post will encourage more go developers to build such a tools that will boost
our productivity.&lt;/p&gt;
</description>
    </item>

    <item>
      <title>Generics in Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-code-generation-and-generics/</link>
      <pubDate>Sun, 18 Oct 2015 05:00:00 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-code-generation-and-generics/</guid>
      <description>

&lt;p&gt;In the article we will take the advantage of [generics] even that they are not
first citizen in &lt;code&gt;Go&lt;/code&gt;. We will explore &lt;a href=&#34;http://clipperhouse.github.io/gen&#34;&gt;gen&lt;/a&gt; and
&lt;a href=&#34;https://github.com/cheekybits/genny&#34;&gt;genny&lt;/a&gt; command line tools.&lt;/p&gt;

&lt;h3 id=&#34;gen&#34;&gt;Gen&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Gen&lt;/code&gt; is a code generation tool that brings some generic query functions. It uses
annotations to add this functionality to any structure. The generated code is
part of your package and does not have any external dependencies. This approach
avoids any reflection and produces an efficient concrete implementation for any
annotated type.&lt;/p&gt;

&lt;p&gt;By default the package generates various query functions. They can be used to
project, filter, sort and group slices of the annotated types.&lt;/p&gt;

&lt;h4 id=&#34;installation&#34;&gt;Installation&lt;/h4&gt;

&lt;p&gt;We should use &lt;code&gt;go get&lt;/code&gt; command to install &lt;code&gt;gen&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get clipperhouse.github.io/gen
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;As any other &lt;code&gt;Go&lt;/code&gt; generation tool, &lt;code&gt;Gen&lt;/code&gt; requires a specific annoation comment
declared before the desired type declaration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +gen [*] tag:&amp;quot;Value, Value[T,T]&amp;quot; anothertag
type AnnotatedType
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It begins with the &lt;code&gt;+gen&lt;/code&gt; directive. Optionally it is followed by a &lt;code&gt;[*]&lt;/code&gt;,
indicating that the generated type should be a pointer. Tags and values are
interpreted by the available type writers. They are responsible for the actual
code generation. We will learn more about them in the next section. For now we
will use the default slice type writer.&lt;/p&gt;

&lt;p&gt;Lets use it to generate functions for filtering, distincting, sorting and projecting
a &lt;code&gt;Company&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: company.go
package company

// +gen slice:&amp;quot;Where,GroupBy[string],DistinctBy,SortBy,Select[string]&amp;quot;
type Company struct {
	Name    string
	Country string
	City    string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After declaring the type annoation, we should execute &lt;code&gt;gen&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It produces &lt;code&gt;comapany_slice.go&lt;/code&gt; file that contains the concrete implementation
for any listed function in the comment.&lt;/p&gt;

&lt;p&gt;Lets use the generated functions with the following slice:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;companies := company.CompanySlice{
	company.Company{Name: &amp;quot;Microsoft&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Redmond&amp;quot;},
	company.Company{Name: &amp;quot;Google&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Palo Alto&amp;quot;},
	company.Company{Name: &amp;quot;Facebook&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Palo Alto&amp;quot;},
	company.Company{Name: &amp;quot;Uber&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;San Francisco&amp;quot;},
	company.Company{Name: &amp;quot;Tweeter&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;San Francisco&amp;quot;},
	company.Company{Name: &amp;quot;SoundCloud&amp;quot;, Country: &amp;quot;Germany&amp;quot;, City: &amp;quot;Berlin&amp;quot;},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets get all companies that are based on USA. For that you should use the &lt;code&gt;Where&lt;/code&gt;
function, which receives predicate function as an argument.&lt;/p&gt;

&lt;p&gt;The clojure function receives a company object as argument and returns
boolean value. It is executed for every item in the slice. It should retun
&lt;code&gt;true&lt;/code&gt; for all objects that meets our criteria:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allUSCompanies := companies.Where(func(comp company.Company) bool {
	return comp.Country == &amp;quot;USA&amp;quot;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we distinct all companies by their country of origin, we should use the
&lt;code&gt;DistinctBy&lt;/code&gt; function that uses a function that checks two company objects
for equaty:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uniqueCompanies := companies.DistinctBy(func(compA company.Company, compB company.Company) bool {
	return compA.Country == compB.Country
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to sort the companies by their name, we should use &lt;code&gt;SortBy&lt;/code&gt; function
that receives as an argument a function that determines whether its first argument
is less that second one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// In our case we can use strings.Compare to compare to strings. It returns -1
// the first string is less than the second.
sortedCompanies := companies.SortBy(func(compA company.Company, compB company.Company) bool {
	return strings.Compare(compA.Name, compB.Name) == -1
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to group the companies by their country of residence, we can use
&lt;code&gt;GroupByString&lt;/code&gt; function that returns a &lt;code&gt;map[string]company.CompanySlice&lt;/code&gt; object.
The key of every entry is determined by its clojure function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;groupedCompanies := companies.GroupByString(func(comp company.Company) string {
	return comp.Country
})

fmt.Println(&amp;quot;US Companies: &amp;quot;, groupedCompanies[&amp;quot;USA&amp;quot;])
fmt.Println(&amp;quot;German Companies: &amp;quot;, groupedCompanies[&amp;quot;Germany&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The company slice can be projected as a string by using generated &lt;code&gt;Select&lt;/code&gt;
function. The following code snippet projects the list of companies as a list
of company names:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;companyNames := companies.SelectString(func(comp company.Company) string {
	return comp.Name
})

fmt.Println(companyNames)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// This slice of strings is produced by the code snippet
[Microsoft Google Facebook Uber Tweeter SoundCloud]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A great &lt;code&gt;Gen&lt;/code&gt; feature is that most of the functions can be chained. Lets select
all companies based in USA then order them by their name and format their name
in the following format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%COMPANY_NAME% is based in %CITY%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can simply chain &lt;code&gt;Where&lt;/code&gt;, &lt;code&gt;SortBy&lt;/code&gt; and &lt;code&gt;SelectString&lt;/code&gt; functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result := companies.Where(func(comp company.Company) bool {
	return comp.Country == &amp;quot;USA&amp;quot;
}).SortBy(func(compA company.Company, compB company.Company) bool {
	return strings.Compare(compA.Name, compB.Name) == -1
}).SelectString(func(comp company.Company) string {
	return fmt.Sprintf(&amp;quot;%s&#39;s is based in %s&amp;quot;, comp.Name, comp.City)
})

for _, text := range result {
	fmt.Println(text)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can read more about another auxiliary function in the &lt;a href=&#34;http://clipperhouse.github.io/gen/slice/&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;implementing-a-type-writer&#34;&gt;Implementing a type writer&lt;/h4&gt;

&lt;p&gt;The type writers are responsible for interpreting the annotated tags and
generating go code. They are implementing the following interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Interface interface {
	Name() string
	Imports(t Type) []ImportSpec
	Write(w io.Writer, t Type) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt; returns the writer&amp;rsquo;s name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Imports&lt;/code&gt; function returns a slice of packages that are required and written
as imports in the generated file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Write&lt;/code&gt; function writes the actual generated code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets implement a writer that generates the &lt;code&gt;Stack&lt;/code&gt; data structure. &lt;code&gt;Gen&lt;/code&gt; uses
&lt;a href=&#34;https://golang.org/pkg/text/template/&#34;&gt;text/template&lt;/a&gt; as a templating format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A structure that represents a stack data structure
// for {{.Name}} type
//
// Example:
// stack := &amp;amp;stack.Stack{}
// stack.Push(new(TValue))
// value, err := stack.Pop()
type {{.Name}}Stack struct {
	data []{{.Pointer}}{{.Name}}
}

// Adds an element on top of the stack
func (s *{{.Name}}Stack) Push(value {{.Pointer}}{{.Name}}) {
	s.data = append(s.data, value)
}

// Removes an element from top of the stack.
// If the stack is empty, it returns an error.
func (s *{{.Name}}Stack) Pop() ({{.Pointer}}{{.Name}}, error) {
	length := len(s.data)
	if length == 0 {
		return nil, errors.New(&amp;quot;Stack is empty&amp;quot;)
	}

	value := s.data[length-1]
	s.data = s.data[:length-1]
	return value, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The template declared by &lt;code&gt;typewriter.Template&lt;/code&gt; instance. The &lt;code&gt;templateContent&lt;/code&gt;
variable contains the actual &lt;code&gt;text/template&lt;/code&gt; string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: templates.go
package stack

import &amp;quot;github.com/clipperhouse/typewriter&amp;quot;

var templates = typewriter.TemplateSlice{
	stackTmpl,
}

var stackTmpl = &amp;amp;typewriter.Template{
	Name: &amp;quot;Stack&amp;quot;,
	Text: templateContent,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following structure implements a type writer responsible for code generation
of declared template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: stack.go
package stack

import (
	&amp;quot;io&amp;quot;

	&amp;quot;github.com/clipperhouse/typewriter&amp;quot;
)

func init() {
	if err := typewriter.Register(NewWriter()); err != nil {
		panic(err)
	}
}

type writer struct{}

// Creates a new stack type writer
func NewWriter() typewriter.Interface {
	return &amp;amp;writer{}
}

func (tw *writer) Name() string {
	return &amp;quot;stack&amp;quot;
}

func (tw *writer) Imports(t typewriter.Type) (result []typewriter.ImportSpec) {
	return
}

func (tw *writer) Write(w io.Writer, t typewriter.Type) error {
  // retrieve that for this type writer a tag is declared in the annoation
	// if it&#39;s not found the writer won&#39;t be generate anything
	tag, found := t.FindTag(tw)

	if !found {
		return nil
	}

  // Write a header commend in the generated file
	header := &amp;quot;// DO NOT MODIFY. Auto-generated code.&amp;quot;
	if _, err := w.Write([]byte(header)); err != nil {
		return err
	}
	
	// A template for the exact tag is retrieved
	tmpl, err := templates.ByTag(t, tag)
	if err != nil {
		return err
	}

  // Write out the template substitution to the writer
	if err := tmpl.Execute(w, t); err != nil {
		return err
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In ored to use the template we should declare annotation. Lets annotate
&lt;code&gt;company.Company&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +gen * stack
type Company struct {
	Name    string
	Country string
	City    string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After executing &lt;code&gt;$ gen&lt;/code&gt; command a &lt;code&gt;company_stack.go&lt;/code&gt; file is placed in the package
directory. It contains an actual implementation of &lt;code&gt;CompanyStack&lt;/code&gt; structure,
which can be used in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stack := &amp;amp;StudentStack{}
stack.Push(&amp;amp;Student{FirstName: &amp;quot;John&amp;quot;, LastName: &amp;quot;Smith&amp;quot;})
student, err := stack.Pop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A complete implementation of the custom type writer can be pulled from
&lt;a href=&#34;https://github.com/svett/gen&#34;&gt;this repository&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;genny&#34;&gt;Genny&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Genny&lt;/code&gt; is a code-generation tool that replaces usage of generics. It allows
to transform a Go source code into specific implementation by replacing its
generic types.&lt;/p&gt;

&lt;h4 id=&#34;installation-1&#34;&gt;Installation&lt;/h4&gt;

&lt;p&gt;Install by executing &lt;code&gt;go get&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/cheekybits/genny
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-1&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;The tool uses a similar approach as &lt;code&gt;gotemplate&lt;/code&gt;. A special comment should be
provided in order to be recognised by &lt;code&gt;go generate&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen &amp;quot;KeyType=string,int ValueType=string,int&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parameters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-in&lt;/code&gt; specifies the input file (template)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-out&lt;/code&gt; specifies the output file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$GOFILE&lt;/code&gt; refers to the current file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyType&lt;/code&gt; and &lt;code&gt;ValueType&lt;/code&gt; are the parameter names in the specified template&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As the other tools, we should just call &lt;code&gt;go generate&lt;/code&gt; to produce a file that is
result of substition between the template and provided parameters.&lt;/p&gt;

&lt;h3 id=&#34;declaring-generics&#34;&gt;Declaring generics&lt;/h3&gt;

&lt;p&gt;The template can contains as many as we require parameters. They should be defined
using the special genny type &lt;code&gt;generic.Type&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type KeyType generic.Type
type ValueType generic.Type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets port the &lt;code&gt;Stack&lt;/code&gt; data struct in &lt;code&gt;genny&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen &amp;quot;ValueType=*Student&amp;quot;
type ValueType generic.Type

type Stack struct {
	data []ValueType
}

func (s *Stack) Push(value TValueType) {
	s.data = append(s.data, value)
}

func (s *Stack) Pop() (TValueType, error) {
	length := len(s.data)
	if length == 0 {
		return nil, errors.New(&amp;quot;Stack is empty&amp;quot;)
	}

	value := s.data[length-1]
	s.data = s.data[:length-1]
	return value, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Significant difference from &lt;code&gt;gotemplate&lt;/code&gt; is that in &lt;code&gt;genny&lt;/code&gt; the special &lt;code&gt;go:generate&lt;/code&gt;
comment should be placed in the actual template. This can be avoid by executing
&lt;code&gt;genny&lt;/code&gt; from the command line shell:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ./stack.go | genny gen &amp;quot;ValueType=*Student&amp;quot; &amp;gt; student_stack.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Do you still complain that &lt;code&gt;Go&lt;/code&gt; does not support generics?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gen&lt;/code&gt; and &lt;code&gt;genny&lt;/code&gt; are great tools for automating a common development tasks. Because of their
template nature, we can focus on what should be generated instead of how to generate it.&lt;/p&gt;
</description>
    </item>

    <item>
      <title>Reusing source code with Go templates</title>
      <link>http://blog.ralch.com/tutorial/golang-code-generation-with-gotemplates/</link>
      <pubDate>Sun, 11 Oct 2015 20:42:57 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-code-generation-with-gotemplates/</guid>
      <description>

&lt;p&gt;In one of my previous blog posts, we discovered &lt;code&gt;go generate&lt;/code&gt; command line
tool. Lets take the next step and evaluate its advanced benefits to generate a source code
by using our own templates. We will explore &lt;a href=&#34;https://github.com/ncw/gotemplate&#34;&gt;gotemplate&lt;/a&gt;
command line tool.&lt;/p&gt;

&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;

&lt;p&gt;This command line tool manages package based &lt;code&gt;Go&lt;/code&gt; templates using &lt;code&gt;go generate&lt;/code&gt;.
By default it provides a set of templates that can be used out of the box:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/ncw/gotemplate/set&#34;&gt;set&lt;/a&gt; - a template that generates a &lt;code&gt;set&lt;/code&gt; struct for a type&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/ncw/gotemplate/list&#34;&gt;list&lt;/a&gt; - a template that generates a &lt;code&gt;list&lt;/code&gt; struct for a type&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/ncw/gotemplate/sort&#34;&gt;sort&lt;/a&gt; - a template that provides a sort primitivies for a type&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/ncw/gotemplate/heap&#34;&gt;heap&lt;/a&gt; - a template that provides &lt;code&gt;heap&lt;/code&gt; operations for a type&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;It is simple to install by using &lt;code&gt;go get&lt;/code&gt; command.
Note that the command installs the predefined templates as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/ncw/gotemplate/...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;To instaciate a particular template, you must use it using a special comment in your code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate gotemplate &amp;quot;github.com/ncw/gotemplate/list&amp;quot; StudentList(Student)
type Student struct {
	FirstName string
	LastName  string
	BirthDate time.Time
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Afte executing &lt;code&gt;go generate&lt;/code&gt; command, a file &lt;a href=&#34;https://gist.github.com/86acbeea21c02af69e70&#34;&gt;gotemplate_StudentList.go&lt;/a&gt;
is generated. It contains the &lt;code&gt;StudentList&lt;/code&gt; type that defines a list struct
that works with &lt;code&gt;Student&lt;/code&gt; type. It has the following methods and functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+StudentList : struct
  [methods]
  +Back() : *StudentListElement
  +Front(): *StudentListElement
  +Init() : *StudentList
  +InsertAfter(v Student, mark *StudentListElement) : *StudentListElement
  +InsertBefore(v Student, mark *StudentListElement) : *StudentListElement
  +Len() : int
  +MoveToBack(e *StudentListElement)
  +MoveToFront(e *StudentListElement)
  +PushBack(v Student) : *StudentListElement
  +PushBackList(other *StudentList)
  +PushFront(v Student) : *StudentListElement
  +PushFrontList(other *StudentList)
  +Remove(e *StudentListElement) : Student
  [functions]
  +NewStudentList() : *StudentList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use it in the following manner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;spike/education&amp;quot;
)

func main() {
	student := education.Student{
		FirstName: &amp;quot;John&amp;quot;,
		LastName:  &amp;quot;Smith&amp;quot;,
	}

	list := education.NewStudentList()
	list.PushFront(student)

	fmt.Println(list.Front().Value.FirstName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using an initial capital when you name your template instantiation will make
any external functions and types public. If you want to generate them as private
you must use lower case like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate gotemplate &amp;quot;github.com/ncw/gotemplate/set&amp;quot; stringSet(string)
//go:generate gotemplate &amp;quot;github.com/ncw/gotemplate/set&amp;quot; floatSet(float64)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then code generation produces &lt;code&gt;gotemplate_stringSet.go&lt;/code&gt; and &lt;code&gt;gotemplate_floateSet.go&lt;/code&gt; files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go generate
substituting &amp;quot;github.com/ncw/gotemplate/set&amp;quot; with stringSet(string) into package main
Written &#39;gotemplate_stringSet.go&#39;
substituting &amp;quot;github.com/ncw/gotemplate/set&amp;quot; with floatSet(float64) into package main
Written &#39;gotemplate_floatSet.go&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;creating-a-custom-templates&#34;&gt;Creating a custom templates&lt;/h3&gt;

&lt;p&gt;Templates must be valid go packages. They should compile and have tests and be usable as-is.&lt;/p&gt;

&lt;p&gt;To make the package a valid template it should have one or more declarations and
a special comment that declares the its template name and parameters.&lt;/p&gt;

&lt;p&gt;The line below indicates that the base name for the template is &lt;code&gt;TemplateType&lt;/code&gt;
and it has one type parameter &lt;code&gt;TParameter&lt;/code&gt;. Supported parameterized declarations
are type, const, var and func.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// template type TemplateType(TParameter)
type TParameter int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets implement a template for &lt;a href=&#34;http://bit.ly/1Pwvd5W&#34;&gt;Stack data structure&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package stack

import &amp;quot;errors&amp;quot;

// template type Stack(TValue)
type TValue *int

type Stack struct {
	data []TValue
}

func (s *Stack) Push(value TValue) {
	s.data = append(s.data, value)
}

func (s *Stack) Pop() (TValue, error) {
	length := len(s.data)
	if length == 0 {
		return nil, errors.New(&amp;quot;Stack is empty&amp;quot;)
	}

	value := s.data[length-1]
	s.data = s.data[:length-1]
	return value, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets declare it for &lt;code&gt;Student&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate gotemplate &amp;quot;github.com/svett/gotemplate/stack&amp;quot; StudentStack(*Student)
type Student struct {
	FirstName string
	LastName  string
	BirthDate time.Time
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can instatiate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/svett/gotemplate/stack
$ go generate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the template is instantiated, a new file &lt;code&gt;gotemplate_StudentStack.go&lt;/code&gt; is create.
It is a result of substition of actual template with &lt;code&gt;StudentStack(*Student)&lt;/code&gt; declaration.
All &lt;code&gt;TValue&lt;/code&gt; occurances are replaced with &lt;code&gt;Student&lt;/code&gt;. The &lt;code&gt;Stack&lt;/code&gt; struct is changed to &lt;code&gt;StudentStack&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The template can be downloaded from &lt;a href=&#34;https://github.com/svett/gotemplate/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Gotemplate&lt;/code&gt; is great tool for automatic a common development tasks. Because of its
extensibility, we can focus on what should be generated instead of how to generate it.&lt;/p&gt;
</description>
    </item>

    <item>
      <title>Golang code generation</title>
      <link>http://blog.ralch.com/tutorial/golang-code-generation/</link>
      <pubDate>Sun, 04 Oct 2015 08:49:59 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-code-generation/</guid>
      <description>

&lt;p&gt;Programs that produce source code are important elements in software engineering.
Since Go 1.4, the language ecosystem includes a command line tool that makes
it easier to run such tools.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s called &lt;code&gt;go generate&lt;/code&gt;. It scans for special comments in Go
source code that identify general commands to run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate &amp;lt;subcommand&amp;gt; &amp;lt;arguments&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Go generate&lt;/code&gt; is not part of go build. It does not do dependency analysis and
must be run explicitly before running go build. It is intended to be used by
the author of the Go package, not its consumers.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;go generate&lt;/code&gt; command is easy to use. Usually it is executed in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// it scans all
$ go generate ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After identifying all &lt;code&gt;go:generate&lt;/code&gt; comments it will execute the specified commands.&lt;/p&gt;

&lt;p&gt;In this article, we will explore a various tools that produce source code for us.&lt;/p&gt;

&lt;h3 id=&#34;json-enums&#34;&gt;JSON Enums&lt;/h3&gt;

&lt;p&gt;Have you ever had an enum that you want to serialize in JSON as a string instead of integer?
Are you bored of developing a &lt;code&gt;switch&lt;/code&gt; cases that handle that? It is time to automate this
task by using &lt;code&gt;jsonenums&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/campoy/jsonenums&#34;&gt;jsonenums&lt;/a&gt; is a code generation tool to automate the creation of methods
that satisfy the &lt;a href=&#34;https://golang.org/pkg/encoding/json/#Marshaler&#34;&gt;json.Marshaler&lt;/a&gt; and &lt;a href=&#34;https://golang.org/pkg/encoding/json/#Unmarshaler&#34;&gt;json.Unmarshaler&lt;/a&gt; interfaces.&lt;/p&gt;

&lt;h4 id=&#34;installing&#34;&gt;Installing&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/campoy/jsonenums
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;Lets have this enum definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate jsonenums -type=Status
type Status int

const (
	Pending Status = iota
	Sent
	Received
	Rejected
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running &lt;code&gt;go generate&lt;/code&gt; produces &lt;code&gt;status_jsonenums.go&lt;/code&gt; file in the same package.
It contains the actual implementation for JSON serialization of &lt;code&gt;Status&lt;/code&gt; enum.
Then we can serialize an enum variable in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;status := Received
data, err := status.MarshalJSON()
if err != nil {
	panic(err)
}

statusCopy := new(Status)
err = statusCopy.UnmarshalJSON(data)
if err != nil {
	panic(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can download the whole code snippet from &lt;a href=&#34;https://gist.github.com/svett/0053bab033a581f7675a&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;fast-json&#34;&gt;Fast JSON&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/pquerna/ffjson&#34;&gt;ffjson&lt;/a&gt;  generates &lt;code&gt;MarshalJSON&lt;/code&gt; and &lt;code&gt;UnmarshalJSON&lt;/code&gt; functions for struct types.
These functions reduce the reliance unpon runtime reflection to do serialization.
According to the author notes, it is generally 2 to 3 times faster than
&lt;code&gt;encoding/json&lt;/code&gt; package.&lt;/p&gt;

&lt;h4 id=&#34;installing-1&#34;&gt;Installing&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/pquerna/ffjson
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-1&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;The generated code is baed upon existing struct types. Lets have &lt;code&gt;education.go&lt;/code&gt; file.
&lt;code&gt;ffjson&lt;/code&gt; will generate a new file &lt;code&gt;education_ffjson.go&lt;/code&gt; that contains serialization
functions for all structs found in &lt;code&gt;education.go&lt;/code&gt;. In order to do that we should
add the following &lt;code&gt;go:generate&lt;/code&gt; comment in &lt;code&gt;education.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate ffjson $GOFILE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a sample version of &lt;code&gt;education.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate ffjson $GOFILE
package education

type Student struct {
	FirstName string
	LastName  string
}

type University struct {
	Name     string
	Students []Student
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing &lt;code&gt;go generate ./...&lt;/code&gt; produces &lt;code&gt;education_ffjson.go&lt;/code&gt; that contains all
json serialization code for &lt;code&gt;Student&lt;/code&gt; and &lt;code&gt;University&lt;/code&gt; structs. Then we can use
&lt;code&gt;ffjson&lt;/code&gt; package to marshal these types and unmasrshal their &lt;code&gt;JSON&lt;/code&gt; representation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;spike/education&amp;quot;

	&amp;quot;github.com/pquerna/ffjson/ffjson&amp;quot;
)

func main() {
	student := education.Student{
		FirstName: &amp;quot;John&amp;quot;,
		LastName:  &amp;quot;Smith&amp;quot;,
	}

	university := education.University{
		Name:     &amp;quot;MIT&amp;quot;,
		Students: []education.Student{student},
	}

	json, err := ffjson.Marshal(&amp;amp;university)
	if err != nil {
		panic(err)
	}

	var universityCopy education.University
	err = ffjson.Unmarshal(json, &amp;amp;universityCopy)
	if err != nil {
		panic(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sample code can be downloaded from &lt;a href=&#34;https://gist.github.com/svett/053b3bd64612a8677389&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;stringer&#34;&gt;Stringer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/stringer&#34;&gt;Stringer&lt;/a&gt; is a similar to &lt;code&gt;jsonenums&lt;/code&gt;.
But it generates a &lt;a href=&#34;https://golang.org/pkg/fmt/#Stringer&#34;&gt;fmt.Stringer interface&lt;/a&gt; implementation for enums.&lt;/p&gt;

&lt;h4 id=&#34;installing-2&#34;&gt;Installing&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get golang.org/x/tools/cmd/stringer
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-2&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;Lets auto-generate &lt;code&gt;fmt.Stringer&lt;/code&gt; interface for &lt;code&gt;MessageStatus&lt;/code&gt; enum:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate stringer -type=MessageStatus
type MessageStatus int

const (
	Sent MessageStatus = iota
	Received
	Rejected
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Go generate&lt;/code&gt; produces &lt;code&gt;messagestatus_string.go&lt;/code&gt; file which contains the actual
implementation. Then the following snippet prints out &lt;code&gt;Message is Sent&lt;/code&gt; instead
of &lt;code&gt;Message is 0&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	status := Sent
	fmt.Printf(&amp;quot;Message is %s&amp;quot;, status)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Full source code can be download from &lt;a href=&#34;https://gist.github.com/svett/b5194dfb109626579e77&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Go generate&lt;/code&gt; is great opportunity to automate many implementation tasks
that are very common in our day to day job. I am really pleased to see more and
more tools coming up.&lt;/p&gt;
</description>
    </item>

  </channel>
</rss>
