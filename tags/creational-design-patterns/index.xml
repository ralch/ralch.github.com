<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/tags/creational-design-patterns/index.xml</link>
    <language>en-us</language>
    <author>Svetlin Ralchev</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Desing Patterns in Golang: Bridge</title>
      <link>http://blog.ralch.com/tutorial/design-patterns/golang-bridge/</link>
      <pubDate>Thu, 17 Mar 2016 17:26:46 UTC</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/design-patterns/golang-bridge/</guid>
      <description>

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;The Bridge Pattern is a creational design pattern used to decouple an
abstraction from its implementation. The bridge uses encapsulation,
aggregation, and can use inheritance to separate responsibilities into
different classes.&lt;/p&gt;

&lt;h4 id=&#34;purpose&#34;&gt;Purpose&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Decouple an abstraction from its implementation that allows both to vary independently.&lt;/li&gt;
&lt;li&gt;Publish interface in an inheritance hierarchy, and bury implementation in its own inheritance hierarchy.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;design-pattern-diagram&#34;&gt;Design Pattern Diagram&lt;/h4&gt;

&lt;p&gt;The objects participating in this pattern are presented on the following diagram:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/design-patterns/bridge.gif&#34; alt=&#34;Bridge Class Diagram&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Abstraction&lt;/code&gt; defines the abstraction&amp;rsquo;s interface and maintains a reference to an object of type &lt;code&gt;Implementor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RefinedAbstraction&lt;/code&gt; extends the interface defined by &lt;code&gt;Abstraction&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Implementor&lt;/code&gt; defines the interface for implementation objects&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteImplementor&lt;/code&gt; implements the &lt;code&gt;Implementor&lt;/code&gt; interface and defines its concrete implementation&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;Consider building an UI package that supports drawing different shapes on the
screen by supporting &lt;code&gt;OpenGL&lt;/code&gt; and &lt;code&gt;Direct2D&lt;/code&gt; rendering technologies. In our
particular example should be able to draw a circle by supporting both rendering
systems.&lt;/p&gt;

&lt;p&gt;In order to do that we should separate the &lt;code&gt;Circle&lt;/code&gt; struct from its drawing
implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Circle represents a circle shape
type Circle struct {
	// DrawingContext for this circle
	DrawingContext Drawer
	// Center of the circle
	Center Point
	// Radius of the circle
	Radius float64
}

// Draw draws a circle
func (circle *Circle) Draw() error {
	rect := Rect{
		Location: Point{
			X: circle.Center.X - circle.Radius,
			Y: circle.Center.Y - circle.Radius,
		},
		Size: Size{
			Width:  2 * circle.Radius,
			Height: 2 * circle.Radius,
		},
	}

	return circle.DrawingContext.DrawEllipseInRect(rect)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Drawer&lt;/code&gt; defines the contract between the &lt;code&gt;Circle&lt;/code&gt; abstraction and its
implementation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Drawer draws on the underlying graphics device
type Drawer interface {
	// DrawEllipseInRect draws an ellipse in rectanlge
	DrawEllipseInRect(Rect) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For every of the supported rendering technologies we should implement a struct
that obeys the &lt;code&gt;Drawer&lt;/code&gt; interface:&lt;/p&gt;

&lt;p&gt;This is a sample implementation of &lt;code&gt;OpenGL&lt;/code&gt; drawer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// OpenGL drawer
type OpenGL struct{}

// DrawEllipseInRect draws an ellipse in rectangle
func (gl *OpenGL) DrawEllipseInRect(r Rect) error {
	fmt.Printf(&amp;quot;OpenGL is drawing ellipse in rect %v&amp;quot;, r)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a sample implementation of &lt;code&gt;Direct2D&lt;/code&gt; drawer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Direct2D drawer
type Direct2D struct{}

// DrawEllipseInRect draws an ellipse in rectangle
func (d2d *Direct2D) DrawEllipseInRect(r Rect) error {
	fmt.Printf(&amp;quot;Direct2D is drawing ellipse in rect %v&amp;quot;, r)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can easily render a circle by using the desired drawing system. We should
just change the implementation by setting &lt;code&gt;DrawingContext&lt;/code&gt; field:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;openGL := &amp;amp;uikit.OpenGL{}
direct2D := &amp;amp;uikit.Direct2D{}

circle := &amp;amp;uikit.Circle{
	Center: uikit.Point{X: 100, Y: 100},
	Radius: 50,
}

circle.DrawingContext = openGL
circle.Draw()

circle.DrawingContext = direct2D
circle.Draw()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;The Bridge Pattern is designed up-front to let the abstraction and the
implementation vary independently. That allows us to independently change the
implementation from its abstraction.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Patterns in Golang: Prototype</title>
      <link>http://blog.ralch.com/tutorial/design-patterns/golang-prototype/</link>
      <pubDate>Sat, 06 Feb 2016 16:01:29 UTC</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/design-patterns/golang-prototype/</guid>
      <description>

&lt;h4 id=&#34;preface&#34;&gt;Preface&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;The Prototype Pattern&lt;/code&gt; creates duplicate objects while keeping performance
in mind. It&amp;rsquo;s a part of the creational patterns and provides one of the best
ways to create an object.&lt;/p&gt;

&lt;p&gt;In the mainstream languages (like C# and JAVA), it requires implementing a
prototype interface which tells to create a clone of the current object. It is
used when creation of object directly is costly.&lt;/p&gt;

&lt;p&gt;For instance, an object is to be created after a costly database operation. We
can cache the object, returns its clone on next request and update the database
as and when needed thus reducing database calls.&lt;/p&gt;

&lt;h4 id=&#34;purpose&#34;&gt;Purpose&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Specify the kind of objects to create using a prototypical instance, and
create new objects by copying this prototype.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;design-pattern-diagram&#34;&gt;Design Pattern Diagram&lt;/h4&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/design-patterns/prototype.gif&#34; alt=&#34;Prototype Class Diagram&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Prototype&lt;/code&gt; declares an interface for cloning itself&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcretePrototype&lt;/code&gt; implements an operation for cloning itself&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt; creates a new object by asking a prototype to clone itself&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;In Golang, the pattern is applicable only in situation that we want to
customize how the object is cloned. We will explore two examples regarding
both situations.&lt;/p&gt;

&lt;p&gt;Lets build a system that generates a different configuration files depending on
our needs. In first place, we have a struct &lt;code&gt;Config&lt;/code&gt; that looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;package configurer

// Config provides a configuration of microservice
type Config struct {
	workDir string
	user    string
}

// NewConfig create a new config
func NewConfig(user string, workDir string) Config {
	return Config{
		user:    user,
		workDir: workDir,
	}
}

// WithWorkDir creates a copy of Config with the provided working directory
func (c Config) WithWorkDir(dir string) Config {
	c.workDir = dir
	return c
}

// WithUser creates a copy of Config with the provided user
func (c Config) WithUser(user string) Config {
	c.user = user
	return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to be able to mutate the object without affecting its initial instance.
The goal is to be able to generate different configuration files without loosing
the flexibility of customizing them without mutation of the initial default
configuration.&lt;/p&gt;

&lt;p&gt;As you can see the functions &lt;code&gt;WithWorkDir&lt;/code&gt;, &lt;code&gt;WithUser&lt;/code&gt; are declared for the
struct &lt;code&gt;Config&lt;/code&gt; (not for &lt;code&gt;*Config&lt;/code&gt;). At the time, when they are called the
object is copied by the &lt;code&gt;Golang&lt;/code&gt; runtime. This allows us to modify it
without affecting the original object.&lt;/p&gt;

&lt;p&gt;Lets see it&amp;rsquo;s usage in action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;config := configurer.NewConfig(&amp;quot;guest&amp;quot;, &amp;quot;/home/guest&amp;quot;)
rootConfig := config.WithUser(&amp;quot;root&amp;quot;).WithWorkDir(&amp;quot;/root&amp;quot;)

fmt.Println(&amp;quot;Guest Config&amp;quot;, config)
fmt.Println(&amp;quot;Root Config&amp;quot;, rootConfig)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lets explore the classic implementation of &lt;code&gt;The Prototype Design Pattern&lt;/code&gt;.
We will assume that we are developing again document object model for a custom
document format. The core object is an &lt;code&gt;Element&lt;/code&gt; structure which has parent and
children.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Element represents an element in document object model
type Element struct {
	text     string
	parent   Node
	children []Node
}

// NewElement makes a new element
func NewElement(text string) *Element {
	return &amp;amp;Element{
		text:     text,
		parent:   nil,
		children: make([]Node, 0),
	}
}

// Parent returns the element parent
func (e *Element) Parent() Node {
	return e.parent
}

// SetParent sets the element parent
func (e *Element) SetParent(node Node) {
	e.parent = node
}

// Children returns the element children elements
func (e *Element) Children() []Node {
	return e.children
}

// AddChild adds a child element
func (e *Element) AddChild(child Node) {
	copy := child.Clone()
	copy.SetParent(e)
	e.children = append(e.children, copy)
}

// Clone makes a copy of particular element. Note that the element becomes a
// root of new orphan tree
func (e *Element) Clone() Node {
	copy := &amp;amp;Element{
		text:     e.text,
		parent:   nil,
		children: make([]Node, 0),
	}
	for _, child := range e.children {
		copy.AddChild(child)
	}
	return copy
}

// String returns string representation of element
func (e *Element) String() string {
	buffer := bytes.NewBufferString(e.text)

	for _, c := range e.Children() {
		text := c.String()
		fmt.Fprintf(buffer, &amp;quot;\n %s&amp;quot;, text)
	}

	return buffer.String()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The contract that exposes the &lt;code&gt;Clone&lt;/code&gt; funcion is the &lt;code&gt;Node&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Node a document object model node
type Node interface {
	// Strings returns nodes text representation
	String() string
	// Parent returns the node parent
	Parent() Node
	// SetParent sets the node parent
	SetParent(node Node)
	// Children returns the node children nodes
	Children() []Node
	// AddChild adds a child node
	AddChild(child Node)
	// Clone clones a node
	Clone() Node
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We want to extract a particular subtree of concrete element hierary. We want to
use it as independent document object model. In order to do that, we should use
the clone function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;directorNode := dom.NewElement(&amp;quot;Director of Engineering&amp;quot;)

engManagerNode := dom.NewElement(&amp;quot;Engineering Manager&amp;quot;)
engManagerNode.AddChild(dom.NewElement(&amp;quot;Lead Software Engineer&amp;quot;))

directorNode.AddChild(engManagerNode)
directorNode.AddChild(engManagerNode)

officeManagerNode := dom.NewElement(&amp;quot;Office Manager&amp;quot;)
directorNode.AddChild(officeManagerNode)

fmt.Println(&amp;quot;&amp;quot;)
fmt.Println(&amp;quot;# Company Hierarchy&amp;quot;)
fmt.Print(directorNode)
fmt.Println(&amp;quot;&amp;quot;)
fmt.Println(&amp;quot;# Team Hiearachy&amp;quot;)
fmt.Print(engManagerNode.Clone())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sample above creates a tree from the subtree pointed by &lt;code&gt;engManagerNode&lt;/code&gt;
variable.&lt;/p&gt;

&lt;p&gt;You can get the full source code from
&lt;a href=&#34;https://github.com/svett/golang-design-patterns/tree/master/creational-patterns/prototype&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;One of the disadvantages of this pattern is that the process of copying an object
can be complicated. In addition, structs that have circular references to other
classes are difficult to clone. Its overuse could affect performance, as the
prototype object itself would need to be instantiated if you use a registry of
prototypes.&lt;/p&gt;

&lt;p&gt;In the context of &lt;code&gt;Golang&lt;/code&gt;, I don&amp;rsquo;t see any particular reason to adopt it.
&lt;code&gt;Golang&lt;/code&gt; already provides builtin mechanism for cloning objects.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Desing Patterns in Golang: Factory Method</title>
      <link>http://blog.ralch.com/tutorial/design-patterns/golang-factory-method/</link>
      <pubDate>Sun, 31 Jan 2016 08:46:53 UTC</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/design-patterns/golang-factory-method/</guid>
      <description>

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;Factory Method&lt;/code&gt; pattern is a design pattern used to define a runtime
interface for creating an object. Itâ€™s called a factory because it creates
various types of objects without necessarily knowing what kind of object it
creates or how to create it.&lt;/p&gt;

&lt;h4 id=&#34;purpose&#34;&gt;Purpose&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Allows the sub-classes to choose the type of objects to create at runtime&lt;/li&gt;
&lt;li&gt;It provides a simple way of extending the family of objects with minor
changes in application code.&lt;/li&gt;
&lt;li&gt;Promotes the loose-coupling by eliminating the need to bind
application-specific structs into the code&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;design-pattern-diagram&#34;&gt;Design Pattern Diagram&lt;/h4&gt;

&lt;p&gt;The structs and objects participating in this pattern are: product,
concreate product, creator and concrete creator. The Creator contains one
method to produce one type of product related to its type.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/design-patterns/factory-method.gif&#34; alt=&#34;Builder Class Diagram&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Product&lt;/code&gt; defines the interface of objects the factory method creates&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteProduct&lt;/code&gt; implements the Product interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Creator&lt;/code&gt; declares the factory method, which returns an object of type Product&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConcreteCreator&lt;/code&gt; overrides the factory method to return an instance of a Concrete Product&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;The Factory Method defines an interface for creating objects, but lets
subclasses decide which classes to instantiate. In these example, we will adopt
the pattern to create document object model of Scalable Vector Graphics.&lt;/p&gt;

&lt;p&gt;The SVG format can contains multiple elements. In this example, we will illustrate
only some of the shape elements. In the context of &lt;code&gt;Factory Method&lt;/code&gt; design pattern,
they are our product.&lt;/p&gt;

&lt;p&gt;Every shape implements the &lt;code&gt;Shape&lt;/code&gt; interface, which expose a &lt;code&gt;Draw&lt;/code&gt; function that
generates the required XML element:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type Shape interface {
	Draw(io.Writer) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the following code snippets, we will illustrate two implementations of &lt;code&gt;Shape&lt;/code&gt;
interface &lt;code&gt;Circle&lt;/code&gt; and &lt;code&gt;Ractangle&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type Circle struct {
	Location Point
	Radius   float64
}

func (c *Circle) Draw(w io.Writer) error {
	_, err := fmt.Fprintf(w, `&amp;lt;circle cx=&amp;quot;%f&amp;quot; cy=&amp;quot;%f&amp;quot; r=&amp;quot;%f&amp;quot;/&amp;gt;`, c.Location.X, c.Location.Y, c.Radius)
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type Rectangle struct {
	Location Point
	Size     Size
}

func (rect *Rectangle) Draw(w io.Writer) error {
	_, err := fmt.Fprintf(w, `&amp;lt;rect x=&amp;quot;%f&amp;quot; y=&amp;quot;%f&amp;quot; width=&amp;quot;%f&amp;quot; height=&amp;quot;%f&amp;quot;/&amp;gt;`, rect.Location.X, rect.Location.Y, rect.Size.Width, rect.Size.Height)
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every of them has a function that is responsible for their instantiation based
on the provided &lt;code&gt;Viewport&lt;/code&gt;. The &lt;code&gt;Viewport&lt;/code&gt; is an argument which keeps an information
about the location and the size of the view port.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type ShapeFactory interface {
	Create(viewport Viewport) Shape
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;CircleFactory&lt;/code&gt; creates a &lt;code&gt;Circle&lt;/code&gt; instance that has radius, which fits
the viewport:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type CircleFactory struct{}

func (factory *CircleFactory) Create(viewport Viewport) Shape {
	return &amp;amp;Circle{
		Location: viewport.Location,
		Radius:   math.Min(viewport.Size.Width, viewport.Size.Height),
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;RectangleFactory&lt;/code&gt; produces a rectangle that fits the viewport:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type RactangleFactory struct{}

func (factory *RactangleFactory) Create(viewport Viewport) Shape {
	return &amp;amp;Rectangle{
		Location: viewport.Location,
		Size:     viewport.Size,
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main object &lt;code&gt;Document&lt;/code&gt; has a &lt;code&gt;Draw&lt;/code&gt; function, which composes a different
shapes created by provided factories. The &lt;code&gt;Document&lt;/code&gt; can be instaciated with
different set of factories. This allow to customize and change the document&amp;rsquo;s
content:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type Document struct {
	ShapeFactories []ShapeFactory
}

func (doc *Document) Draw(w io.Writer) error {
	viewport := Viewport{
		Location: Point{
			X: 0,
			Y: 0,
		},
		Size: Size{
			Width:  640,
			Height: 480,
		},
	}
	if _, err := fmt.Fprintf(w, `&amp;lt;svg height=&amp;quot;%f&amp;quot; width=&amp;quot;%f&amp;quot;&amp;gt;`, viewport.Size.Height, viewport.Size.Width); err != nil {
		return err
	}

	for _, factory := range doc.ShapeFactories {
		shape := factory.Create(viewport)
		if err := shape.Draw(w); err != nil {
			return err
		}
	}

	_, err := fmt.Fprint(w, `&amp;lt;/svg&amp;gt;`)
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should instaciate the &lt;code&gt;Document&lt;/code&gt; struct with the available factories in
the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;doc := &amp;amp;svg.Document{
	ShapeFactories: []svg.ShapeFactory{
		&amp;amp;svg.CircleFactory{},
		&amp;amp;svg.RactangleFactory{},
	},
}

doc.Draw(os.Stdout)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can get the full source code from &lt;a href=&#34;https://github.com/svett/golang-design-patterns/tree/master/creational-patterns/factory-method&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Important aspects when we implement the Factory Method design pattern are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Designing the arguments of the factory method&lt;/li&gt;
&lt;li&gt;Considering an internal object pool that will allow object cache and reuse instead
of created from scratch&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;The Factory Method is one of the most used design patterns. It makes a design
more customizable and only a little more complicated. Other design patterns
require new structs, whereas Factory Method only requires a new operation.
The Factory Method is similar to Abstract Factory but without the emphasis on
families.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Desing Patterns in Golang: Builder</title>
      <link>http://blog.ralch.com/tutorial/design-patterns/golang-builder/</link>
      <pubDate>Sun, 24 Jan 2016 08:46:53 UTC</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/design-patterns/golang-builder/</guid>
      <description>

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;The Builder Pattern is a creational design pattern that&amp;rsquo;s used to
encapsulate the construction logic for an object. It is often used
when the construction process of an object is complex. The patterns is well
suited for constructing different representations of the same class.&lt;/p&gt;

&lt;h4 id=&#34;purpose&#34;&gt;Purpose&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Separate the construction of a complex object from its representation so that
the same construction process can create different representations.&lt;/li&gt;
&lt;li&gt;A common software creational design pattern that&amp;rsquo;s used to encapsulate the
construction logic for an object.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;design-pattern-diagram&#34;&gt;Design Pattern Diagram&lt;/h4&gt;

&lt;p&gt;The Builder Pattern is comprised of four components: a builder interface, a
concrete builder, a director and a product.&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/design-patterns/builder.gif&#34; alt=&#34;Builder Class Diagram&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Builder&lt;/code&gt; defines a template for the steps to construct the product.
Specifies an abstract interface for creating parts of a Product object.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Concrete Builder&lt;/code&gt; implements the builder interface and provides an interface
for getting the product. Constructs and assembles parts of the product by
implementing the Builder interface defines and keeps track of the
representation it creates provides an interface for retrieving the product.
&lt;code&gt;ConcreteBuilder&lt;/code&gt; builds the product&amp;rsquo;s internal representation and defines
the process by which it&amp;rsquo;s assembled includes classes that define the
constituent parts, including interfaces for assembling the parts into the
final result.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Director&lt;/code&gt; constructs the object through the builder interface.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Product&lt;/code&gt; is the main object that&amp;rsquo;s constructed. Represents the complex
object under construction.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;The Builder pattern separates the construction of a complex object from its
representation so that the same construction process can create different
representations. This pattern is used by mail service to construct
children&amp;rsquo;s mails to Santa Claus.&lt;/p&gt;

&lt;p&gt;Note that there can be variation in the content of the children&amp;rsquo;s emails, but the
construction process is the same. In the example, the service supports &lt;code&gt;JSON&lt;/code&gt;
and &lt;code&gt;XML&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The messages typically consist of body and format. They can be transmitted via
different protocol. In order to do that their body should be encoded in the right
format.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Message is the Product object in Builder Design Pattern
type Message struct {
	// Message Body
	Body []byte
	// Message Format
	Format string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every message body should consist the recipient and text. Therefore, the Builder
interface provides a functions to set these attributes. The &lt;code&gt;Message&lt;/code&gt; function
is responsible for constructing the actual message in the right format.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// MessageBuilder is the inteface that every concrete implementation
// should obey
type MessageBuilder interface {
	// Set the message&#39;s recipient
	SetRecipient(recipient string)
	// Set the message&#39;s text
	SetText(text string)
	// Returns the built Message
	Message() (*Message, error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;JSONMessageBuilder&lt;/code&gt; is a concrete implementation of the &lt;code&gt;MessageBuilder&lt;/code&gt;
interface. It uses &lt;a href=&#34;http://golang.org/pkg/encoding/json/&#34;&gt;json&lt;/a&gt; package to
encode the message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// JSON Message Builder is concrete builder
type JSONMessageBuilder struct {
	messageRecipient string
	messageText      string
}

func (b *JSONMessageBuilder) SetRecipient(recipient string) {
	b.messageRecipient = recipient
}

func (b *JSONMessageBuilder) SetText(text string) {
	b.messageText = text
}

func (b *JSONMessageBuilder) Message() (*Message, error) {
	m := make(map[string]string)
	m[&amp;quot;recipient&amp;quot;] = b.messageRecipient
	m[&amp;quot;message&amp;quot;] = b.messageText

	data, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}

	return &amp;amp;Message{Body: data, Format: &amp;quot;JSON&amp;quot;}, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;XMLMessageBuilder&lt;/code&gt; is a concrete implementation of the &lt;code&gt;MessageBuilder&lt;/code&gt;
interface. It uses &lt;a href=&#34;http://golang.org/pkg/encoding/xml/&#34;&gt;xml&lt;/a&gt; package to encode
the message.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// XML Message Builder is concrete builder
type XMLMessageBuilder struct {
	messageRecipient string
	messageText      string
}

func (b *XMLMessageBuilder) SetRecipient(recipient string) {
	b.messageRecipient = recipient
}

func (b *XMLMessageBuilder) SetText(text string) {
	b.messageText = text
}

func (b *XMLMessageBuilder) Message() (*Message, error) {
	type XMLMessage struct {
		Recipient string `xml:&amp;quot;recipient&amp;quot;`
		Text      string `xml:&amp;quot;body&amp;quot;`
	}

	m := XMLMessage{
		Recipient: b.messageRecipient,
		Text:      b.messageText,
	}

	data, err := xml.Marshal(m)
	if err != nil {
		return nil, err
	}

	return &amp;amp;Message{Body: data, Format: &amp;quot;XML&amp;quot;}, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sender object decides what should be the content of the email and its
recipient (ex. Santa Claus).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Sender is the Director in Builder Design Pattern
type Sender struct{}

// Build a concrete message via MessageBuilder
func (s *Sender) BuildMessage(builder MessageBuilder) (*Message, error) {
	builder.SetRecipient(&amp;quot;Santa Claus&amp;quot;)
	builder.SetText(&amp;quot;I have tried to be good all year and hope that you and your reindeers will be able to deliver me a nice present.&amp;quot;)
	return builder.Message()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should use the designed architecture to build XML and JSON messages in the
following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;sender := &amp;amp;messenger.Sender{}

jsonMsg, err := sender.BuildMessage(&amp;amp;messenger.JSONMessageBuilder{})
if err != nil {
	panic(err)
}

fmt.Println(string(jsonMsg.Body))

xmlMsg, err := sender.BuildMessage(&amp;amp;messenger.XMLMessageBuilder{})
if err != nil {
	panic(err)
}

fmt.Println(string(xmlMsg.Body))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;As you can see, the true strength of the Builder Pattern is that it lets you
break up the construction of a complex object. Not only that, it also allows
you to hide the construction process from the consumer, thus allowing for
additional representations of the product to be added with ease. The pattern
also encourages separation of concerns and promotes application extensibility&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Design Patterns in Golang: Singleton</title>
      <link>http://blog.ralch.com/tutorial/design-patterns/golang-singleton/</link>
      <pubDate>Sun, 17 Jan 2016 13:35:05 UTC</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/design-patterns/golang-singleton/</guid>
      <description>

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;Sometimes it&amp;rsquo;s important to have only one instance of an struct. This is useful
when exactly one object is needed to coordinate actions across the system.
Singletons provide a global point of access to themselves.&lt;/p&gt;

&lt;p&gt;The singleton pattern is one of the simplest design patterns. It requires only
one type which is responsible to instantiate itself, to make sure it creates
not more than one instance. The same instance can be used from everywhere.&lt;/p&gt;

&lt;h4 id=&#34;purpose&#34;&gt;Purpose&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Ensure that only one instance of a class is created for application lifecycle.&lt;/li&gt;
&lt;li&gt;Provide a single point of access to the object.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;design-pattern-diagram&#34;&gt;Design Pattern Diagram&lt;/h4&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/design-patterns/singleton.gif&#34; alt=&#34;Singleton Class Diagram&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;In Golang the Singleon pattern implementation defers from another languages due
to the language differences.&lt;/p&gt;

&lt;p&gt;In langauges like &lt;code&gt;C#&lt;/code&gt; and &lt;code&gt;JAVA&lt;/code&gt;, the implementation involves a static member
in the &lt;code&gt;Singleton&lt;/code&gt; class, a private constructor and a static public method that
returns a reference to the static member.&lt;/p&gt;

&lt;p&gt;In Golang the static member of the &lt;code&gt;Singleton&lt;/code&gt; struct is declared as a global
variable in the package that contains this type.&lt;/p&gt;

&lt;p&gt;Lets have a &lt;code&gt;db&lt;/code&gt; package that should provide a &lt;code&gt;repository&lt;/code&gt; struct as a
singleton object. Note that we should define the struct with lowercase letters
in order to make it private. This will disallow instaciating the struct outside
the package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;package db

import &amp;quot;fmt&amp;quot;

type repository struct {
	items map[string]string
	mu    sync.RWMutex
}

func (r *repository) Set(key, data string) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.items[key] = data
}

func (r *repository) Get(key string) (string, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	item, ok := r.items[key]
	if !ok {
		return &amp;quot;&amp;quot;, fmt.Errorf(&amp;quot;The &#39;%s&#39; is not presented&amp;quot;, key)
	}
	return item, nil
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we should declare a global variable of type pointer to &lt;code&gt;repository&lt;/code&gt; that will
keep an reference to its singleton instance. Then we should declare a function
&lt;code&gt;Repository&lt;/code&gt; that provides a global point of access to that instance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;var (
	r *repository
)

func Repository() *repository {
	if r == nil {
		r = &amp;amp;repository{
			items: make(map[string]string)
		}
	}
	return r
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function &lt;code&gt;Repository&lt;/code&gt; instanciate the singleton object once if it has not
been instance. It checks whether the &lt;code&gt;repository&lt;/code&gt; global variable is &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;thread-safety&#34;&gt;Thread safety&lt;/h4&gt;

&lt;p&gt;A robust singleton implementation should work in any circumstances. This is why
we need to ensure it works when multiple go routines use it.&lt;/p&gt;

&lt;p&gt;The standard implementation requires to synchronize the action that instanciate
the singleton object once.&lt;/p&gt;

&lt;p&gt;In order to achieve that we should use the &lt;a href=&#34;https://golang.org/pkg/sync/&#34;&gt;sync&lt;/a&gt;
package. It provides a &lt;a href=&#34;https://golang.org/pkg/sync/#Once&#34;&gt;sync.Once&lt;/a&gt; struct
that will perform exactly one action:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;var (
	r    *repository
	once sync.Once
)

func Repository() *repository {
	once.Do(func() {
		r = &amp;amp;repository{
			items: make(map[string]string),
		}
	})
	
	return r
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;The Singleton design pattern is a very useful mechanism for providing a single
point of object access in an object-oriented application. Regardless of the
implementation used, the pattern provides a commonly understood concept that
can be easily shared among design and development teams.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
