<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/tags/errors/index.xml</link>
    <language>en-us</language>
    <author>Svett Ralchev</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Errors handling in Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-handling-errors/</link>
      <pubDate>Thu, 10 Mar 2016 08:52:29 UTC</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-handling-errors/</guid>
      <description>

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; does not have an &lt;code&gt;Exception&lt;/code&gt; handling model as most of the main stream
languages. However, it uses the error interface type as the return type for any
error that is going to be returned from a function or method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type error interface {
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is an interface type. An error variable represents any value
that can describe itself as a string. The most commonly-used error
implementation is in the &lt;a href=&#34;https://golang.org/pkg/errors/&#34;&gt;errors&lt;/a&gt; package.&lt;/p&gt;

&lt;p&gt;It can be instaciated in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;func DivideBy(divider float64) (float64, error) {
    if divider &amp;lt;= 0 {
        return 0, errors.New(&amp;quot;Divider cannot be zero or negative number.&amp;quot;)
    }
    // implementation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;errors.New&lt;/code&gt; functions constructs an exported type &lt;code&gt;errorString&lt;/code&gt; that
implements the &lt;code&gt;Error&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package errors implements functions to manipulate errors.
package errors

// New returns an error that formats as the given text.
func New(text string) error {
	return &amp;amp;errorString{text}
}

// errorString is a trivial implementation of error.
type errorString struct {
	s string
}

func (e *errorString) Error() string {
	return e.s
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is pretty straighforward to implement your own error type that has additional
data.&lt;/p&gt;

&lt;p&gt;The error model in &lt;code&gt;Golang&lt;/code&gt; does not provide a way to find out, which function
returned the error. We should be aware and log the errors very carefully in
order to understand where this error occurred.&lt;/p&gt;

&lt;p&gt;Fortunately, the &lt;code&gt;Golang&lt;/code&gt; runtime provides a set of functions that we can use to
generate a stacktrace that we can trace down easily.&lt;/p&gt;

&lt;p&gt;In the following paragraphs, we will explore the Planatir
&lt;a href=&#34;https://github.com/palantir/stacktrace&#34;&gt;stacktrace&lt;/a&gt; package that does this for
us.&lt;/p&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;

&lt;p&gt;The package captures a strategic places along the call stack and attaches relevant
contextual information like messages and variables. It is keeping stack traces
compact and maximally useful.&lt;/p&gt;

&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;In order to use the package, we should install it first by using the well known
&lt;code&gt;go get&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;$ go get github.com/palantir/stacktrace
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;The package provides a various functions to propagate and generate that
contextual information.&lt;/p&gt;

&lt;h5 id=&#34;error-propagation&#34;&gt;Error propagation&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;stacktrace.Propagate&lt;/code&gt; function replaces the usage of &lt;code&gt;fmt.Errorf&lt;/code&gt; function. It
wraps an error to include line number information. This is going to be your
most common stacktrace call.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;db, err := sql.Open(&amp;quot;postgres&amp;quot;, conninfo)
if err != nil {
   return stacktrace.Propagate(err, &amp;quot;Failed to connect %v&amp;quot;, conninfo)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;creating-errors&#34;&gt;Creating errors&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;stacktrace.NewError&lt;/code&gt; creates a new error that includes line number information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;if amount &amp;lt;= 0 {
    return stacktrace.NewError(&amp;quot;Expected amount %v to be positive number&amp;quot;, arg)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;error-codes&#34;&gt;Error Codes&lt;/h5&gt;

&lt;p&gt;Sometimes it&amp;rsquo;s useful to propagate an error code while unwinding the
stack. For instance, a RESTful API may use the error code to set the HTTP status
code. The type &lt;code&gt;stacktrace.ErrorCode&lt;/code&gt; is used to name the set of error codes
relevant to your application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;const (
    ConnectionTimeout = stacktrace.ErrorCode(iota)
		ConnectionLost
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The value &lt;code&gt;stacktrace.NoCode&lt;/code&gt; is equal to &lt;code&gt;math.MaxUint16&lt;/code&gt;, so avoid using
that. &lt;code&gt;NoCode&lt;/code&gt; is the default value of errors that does not have explicitly set
error code.&lt;/p&gt;

&lt;p&gt;You can use &lt;code&gt;stacktrace.PropagateWithCode&lt;/code&gt; and &lt;code&gt;stacktrace.NewErrorWithCode&lt;/code&gt; to
instaciated an error that has specific code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;db, err := sql.Open(&amp;quot;postgres&amp;quot;, conninfo)
if err != nil {
   return stacktrace.PropagateWithCode(err, ConnectionTimeout, &amp;quot;Failed to connect %v&amp;quot;, conninfo)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can extract the error code from the error by using &lt;code&gt;stacktrace.GetCode&lt;/code&gt;
function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;data, err := fetch()
if err != nil {
  code := stacktrace.GetCode(err)
	if code == ConnectionTimeout {
	   return nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;verdict&#34;&gt;Verdict&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;stacktrace&lt;/code&gt; package is very pleasant and easy to use. It comforms the Golang
idiomatic way of handling errors and provides us with additional contextual information
about the file and the line where the error occurred.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
