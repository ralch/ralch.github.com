<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/tags/generics/index.xml</link>
    <language>en-us</language>
    <author>Svetlin Ralchev</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Generics in Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-code-generation-and-generics/</link>
      <pubDate>Sun, 18 Oct 2015 05:00:00 &#43;0100</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-code-generation-and-generics/</guid>
      <description>

&lt;p&gt;In the article we will take the advantage of [generics] even that they are not
first citizen in &lt;code&gt;Go&lt;/code&gt;. We will explore &lt;a href=&#34;http://clipperhouse.github.io/gen&#34;&gt;gen&lt;/a&gt; and
&lt;a href=&#34;https://github.com/cheekybits/genny&#34;&gt;genny&lt;/a&gt; command line tools.&lt;/p&gt;

&lt;h3 id=&#34;gen&#34;&gt;Gen&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Gen&lt;/code&gt; is a code generation tool that brings some generic query functions. It uses
annotations to add this functionality to any structure. The generated code is
part of your package and does not have any external dependencies. This approach
avoids any reflection and produces an efficient concrete implementation for any
annotated type.&lt;/p&gt;

&lt;p&gt;By default the package generates various query functions. They can be used to
project, filter, sort and group slices of the annotated types.&lt;/p&gt;

&lt;h4 id=&#34;installation&#34;&gt;Installation&lt;/h4&gt;

&lt;p&gt;We should use &lt;code&gt;go get&lt;/code&gt; command to install &lt;code&gt;gen&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get clipperhouse.github.io/gen 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;As any other &lt;code&gt;Go&lt;/code&gt; generation tool, &lt;code&gt;Gen&lt;/code&gt; requires a specific annoation comment
declared before the desired type declaration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +gen [*] tag:&amp;quot;Value, Value[T,T]&amp;quot; anothertag
type AnnotatedType
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It begins with the &lt;code&gt;+gen&lt;/code&gt; directive. Optionally it is followed by a &lt;code&gt;[*]&lt;/code&gt;,
indicating that the generated type should be a pointer. Tags and values are
interpreted by the available type writers. They are responsible for the actual
code generation. We will learn more about them in the next section. For now we
will use the default slice type writer.&lt;/p&gt;

&lt;p&gt;Lets use it to generate functions for filtering, distincting, sorting and projecting
a &lt;code&gt;Company&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: company.go
package company

// +gen slice:&amp;quot;Where,GroupBy[string],DistinctBy,SortBy,Select[string]&amp;quot;
type Company struct {
	Name    string
	Country string
	City    string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After declaring the type annoation, we should execute &lt;code&gt;gen&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It produces &lt;code&gt;comapany_slice.go&lt;/code&gt; file that contains the concrete implementation
for any listed function in the comment.&lt;/p&gt;

&lt;p&gt;Lets use the generated functions with the following slice:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;companies := company.CompanySlice{
	company.Company{Name: &amp;quot;Microsoft&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Redmond&amp;quot;},
	company.Company{Name: &amp;quot;Google&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Palo Alto&amp;quot;},
	company.Company{Name: &amp;quot;Facebook&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Palo Alto&amp;quot;},
	company.Company{Name: &amp;quot;Uber&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;San Francisco&amp;quot;},
	company.Company{Name: &amp;quot;Tweeter&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;San Francisco&amp;quot;},
	company.Company{Name: &amp;quot;SoundCloud&amp;quot;, Country: &amp;quot;Germany&amp;quot;, City: &amp;quot;Berlin&amp;quot;},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets get all companies that are based on USA. For that you should use the &lt;code&gt;Where&lt;/code&gt;
function, which receives predicate function as an argument.&lt;/p&gt;

&lt;p&gt;The clojure function receives a company object as argument and returns
boolean value. It is executed for every item in the slice. It should retun
&lt;code&gt;true&lt;/code&gt; for all objects that meets our criteria:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allUSCompanies := companies.Where(func(comp company.Company) bool {
	return comp.Country == &amp;quot;USA&amp;quot;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we distinct all companies by their country of origin, we should use the
&lt;code&gt;DistinctBy&lt;/code&gt; function that uses a function that checks two company objects
for equaty:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uniqueCompanies := companies.DistinctBy(func(compA company.Company, compB company.Company) bool {
	return compA.Country == compB.Country
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to sort the companies by their name, we should use &lt;code&gt;SortBy&lt;/code&gt; function
that receives as an argument a function that determines whether its first argument
is less that second one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// In our case we can use strings.Compare to compare to strings. It returns -1
// the first string is less than the second.
sortedCompanies := companies.SortBy(func(compA company.Company, compB company.Company) bool {
	return strings.Compare(compA.Name, compB.Name) == -1
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to group the companies by their country of residence, we can use
&lt;code&gt;GroupByString&lt;/code&gt; function that returns a &lt;code&gt;map[string]company.CompanySlice&lt;/code&gt; object.
The key of every entry is determined by its clojure function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;groupedCompanies := companies.GroupByString(func(comp company.Company) string {
	return comp.Country
})

fmt.Println(&amp;quot;US Companies: &amp;quot;, groupedCompanies[&amp;quot;USA&amp;quot;])
fmt.Println(&amp;quot;German Companies: &amp;quot;, groupedCompanies[&amp;quot;Germany&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The company slice can be projected as a string by using generated &lt;code&gt;Select&lt;/code&gt;
function. The following code snippet projects the list of companies as a list
of company names:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;companyNames := companies.SelectString(func(comp company.Company) string {
	return comp.Name
})

fmt.Println(companyNames)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// This slice of strings is produced by the code snippet
[Microsoft Google Facebook Uber Tweeter SoundCloud]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A great &lt;code&gt;Gen&lt;/code&gt; feature is that most of the functions can be chained. Lets select
all companies based in USA then order them by their name and format their name
in the following format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%COMPANY_NAME% is based in %CITY%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can simply chain &lt;code&gt;Where&lt;/code&gt;, &lt;code&gt;SortBy&lt;/code&gt; and &lt;code&gt;SelectString&lt;/code&gt; functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result := companies.Where(func(comp company.Company) bool {
	return comp.Country == &amp;quot;USA&amp;quot;
}).SortBy(func(compA company.Company, compB company.Company) bool {
	return strings.Compare(compA.Name, compB.Name) == -1
}).SelectString(func(comp company.Company) string {
	return fmt.Sprintf(&amp;quot;%s&#39;s is based in %s&amp;quot;, comp.Name, comp.City)
})

for _, text := range result {
	fmt.Println(text)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can read more about another auxiliary function in the &lt;a href=&#34;http://clipperhouse.github.io/gen/slice/&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;implementing-a-type-writer&#34;&gt;Implementing a type writer&lt;/h4&gt;

&lt;p&gt;The type writers are responsible for interpreting the annotated tags and
generating go code. They are implementing the following interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Interface interface {
	Name() string
	Imports(t Type) []ImportSpec
	Write(w io.Writer, t Type) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt; returns the writer&amp;rsquo;s name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Imports&lt;/code&gt; function returns a slice of packages that are required and written
as imports in the generated file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Write&lt;/code&gt; function writes the actual generated code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets implement a writer that generates the &lt;code&gt;Stack&lt;/code&gt; data structure. &lt;code&gt;Gen&lt;/code&gt; uses
&lt;a href=&#34;https://golang.org/pkg/text/template/&#34;&gt;text/template&lt;/a&gt; as a templating format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A structure that represents a stack data structure
// for {{.Name}} type
//
// Example:
// stack := &amp;amp;stack.Stack{}
// stack.Push(new(TValue))
// value, err := stack.Pop()
type {{.Name}}Stack struct {
	data []{{.Pointer}}{{.Name}}
}

// Adds an element on top of the stack
func (s *{{.Name}}Stack) Push(value {{.Pointer}}{{.Name}}) {
	s.data = append(s.data, value)
}

// Removes an element from top of the stack.
// If the stack is empty, it returns an error.
func (s *{{.Name}}Stack) Pop() ({{.Pointer}}{{.Name}}, error) {
	length := len(s.data)
	if length == 0 {
		return nil, errors.New(&amp;quot;Stack is empty&amp;quot;)
	}

	value := s.data[length-1]
	s.data = s.data[:length-1]
	return value, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The template declared by &lt;code&gt;typewriter.Template&lt;/code&gt; instance. The &lt;code&gt;templateContent&lt;/code&gt;
variable contains the actual &lt;code&gt;text/template&lt;/code&gt; string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: templates.go
package stack

import &amp;quot;github.com/clipperhouse/typewriter&amp;quot;

var templates = typewriter.TemplateSlice{
	stackTmpl,
}

var stackTmpl = &amp;amp;typewriter.Template{
	Name: &amp;quot;Stack&amp;quot;,
	Text: templateContent,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following structure implements a type writer responsible for code generation
of declared template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: stack.go
package stack

import (
	&amp;quot;io&amp;quot;

	&amp;quot;github.com/clipperhouse/typewriter&amp;quot;
)

func init() {
	if err := typewriter.Register(NewWriter()); err != nil {
		panic(err)
	}
}

type writer struct{}

// Creates a new stack type writer
func NewWriter() typewriter.Interface {
	return &amp;amp;writer{}
}

func (tw *writer) Name() string {
	return &amp;quot;stack&amp;quot;
}

func (tw *writer) Imports(t typewriter.Type) (result []typewriter.ImportSpec) {
	return
}

func (tw *writer) Write(w io.Writer, t typewriter.Type) error {
  // retrieve that for this type writer a tag is declared in the annoation
	// if it&#39;s not found the writer won&#39;t be generate anything
	tag, found := t.FindTag(tw)

	if !found {
		return nil
	}

  // Write a header commend in the generated file
	header := &amp;quot;// DO NOT MODIFY. Auto-generated code.&amp;quot;
	if _, err := w.Write([]byte(header)); err != nil {
		return err
	}
	
	// A template for the exact tag is retrieved
	tmpl, err := templates.ByTag(t, tag)
	if err != nil {
		return err
	}

  // Write out the template substitution to the writer
	if err := tmpl.Execute(w, t); err != nil {
		return err
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In ored to use the template we should declare annotation. Lets annotate
&lt;code&gt;company.Company&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +gen * stack
type Company struct {
	Name    string
	Country string
	City    string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After executing &lt;code&gt;$ gen&lt;/code&gt; command a &lt;code&gt;company_stack.go&lt;/code&gt; file is placed in the package
directory. It contains an actual implementation of &lt;code&gt;CompanyStack&lt;/code&gt; structure,
which can be used in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stack := &amp;amp;StudentStack{}
stack.Push(&amp;amp;Student{FirstName: &amp;quot;John&amp;quot;, LastName: &amp;quot;Smith&amp;quot;})
student, err := stack.Pop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A complete implementation of the custom type writer can be pulled from
&lt;a href=&#34;https://github.com/svett/gen&#34;&gt;this repository&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;genny&#34;&gt;Genny&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Genny&lt;/code&gt; is a code-generation tool that replaces usage of generics. It allows
to transform a Go source code into specific implementation by replacing its
generic types.&lt;/p&gt;

&lt;h4 id=&#34;installation-1&#34;&gt;Installation&lt;/h4&gt;

&lt;p&gt;Install by executing &lt;code&gt;go get&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/cheekybits/genny
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-1&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;The tool uses a similar approach as &lt;code&gt;gotemplate&lt;/code&gt;. A special comment should be
provided in order to be recognised by &lt;code&gt;go generate&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen &amp;quot;KeyType=string,int ValueType=string,int&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parameters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-in&lt;/code&gt; specifies the input file (template)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-out&lt;/code&gt; specifies the output file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$GOFILE&lt;/code&gt; refers to the current file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyType&lt;/code&gt; and &lt;code&gt;ValueType&lt;/code&gt; are the parameter names in the specified template&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As the other tools, we should just call &lt;code&gt;go generate&lt;/code&gt; to produce a file that is
result of substition between the template and provided parameters.&lt;/p&gt;

&lt;h3 id=&#34;declaring-generics&#34;&gt;Declaring generics&lt;/h3&gt;

&lt;p&gt;The template can contains as many as we require parameters. They should be defined
using the special genny type &lt;code&gt;generic.Type&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type KeyType generic.Type
type ValueType generic.Type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets port the &lt;code&gt;Stack&lt;/code&gt; data struct in &lt;code&gt;genny&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen &amp;quot;ValueType=*Student&amp;quot;
type ValueType generic.Type

type Stack struct {
	data []ValueType
}

func (s *Stack) Push(value TValueType) {
	s.data = append(s.data, value)
}

func (s *Stack) Pop() (TValueType, error) {
	length := len(s.data)
	if length == 0 {
		return nil, errors.New(&amp;quot;Stack is empty&amp;quot;)
	}

	value := s.data[length-1]
	s.data = s.data[:length-1]
	return value, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Significant difference from &lt;code&gt;gotemplate&lt;/code&gt; is that in &lt;code&gt;genny&lt;/code&gt; the special &lt;code&gt;go:generate&lt;/code&gt;
comment should be placed in the actual template. This can be avoid by executing
&lt;code&gt;genny&lt;/code&gt; from the command line shell:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ./stack.go | genny gen &amp;quot;ValueType=*Student&amp;quot; &amp;gt; student_stack.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Do you still complain that &lt;code&gt;Go&lt;/code&gt; does not support generics?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gen&lt;/code&gt; and &lt;code&gt;genny&lt;/code&gt; are great tools for automating a common development tasks. Because of their
template nature, we can focus on what should be generated instead of how to generate it.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
