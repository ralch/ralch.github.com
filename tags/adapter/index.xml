<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/tags/adapter/index.xml</link>
    <language>en-us</language>
    <author>Svetlin Ralchev</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Design Patterns in Golang: Adapter</title>
      <link>http://blog.ralch.com/tutorial/design-patterns/golang-adapter/</link>
      <pubDate>Mon, 22 Feb 2016 08:42:38 UTC</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/design-patterns/golang-adapter/</guid>
      <description>

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;The Adapter Pattern&lt;/code&gt; is responsible for adaptation of two incompatible
interfaces. It is a structural pattern that is responsible to join
functionalities of independent or incompatible interfaces without modifing
their implementation.&lt;/p&gt;

&lt;p&gt;Interfaces may be incompatible but the inner functionality should suit the
need. It allows otherwise incompatible objects to work together by converting
the interface of each struct into an interface expected by the clients.&lt;/p&gt;

&lt;h4 id=&#34;purpose&#34;&gt;Purpose&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Impedance match an old component to a new system&lt;/li&gt;
&lt;li&gt;Wrap the interface of a object into another interface clients expect.&lt;/li&gt;
&lt;li&gt;Adapter lets objects work together, that could not otherwise because of incompatible interfaces.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;design-pattern-diagram&#34;&gt;Design Pattern Diagram&lt;/h4&gt;

&lt;p&gt;The structs/objects that are participating in adapter pattern are illustrated
in the following diagram:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/design-patterns/adapter.gif&#34; alt=&#34;Adapter Class Diagram&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Target&lt;/code&gt; is the domain-specific interface that Client wants to use.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Adapter&lt;/code&gt; adapts the interface &lt;code&gt;Adaptee&lt;/code&gt; to the &lt;code&gt;Target&lt;/code&gt; interface. It
implements the &lt;code&gt;Target&lt;/code&gt; interface in terms of the Adaptee.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Adaptee&lt;/code&gt; defines an existing interface that needs adapting.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Client&lt;/code&gt; collaborates with objects conforming to the &lt;code&gt;Target&lt;/code&gt; interface.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;Target&lt;/code&gt; interface enables objects of adaptee types to be interchangeable
with any other objects that might implement the same interface. However, the
adaptees might not conform to the &lt;code&gt;Target&lt;/code&gt;. The interface alone is not a
sufficiently powerful mechanism. We need the Adapter pattern. An &lt;code&gt;Adaptee&lt;/code&gt;
offers similar functionality to the client, but under a different name and with
possibly different parameters. The &lt;code&gt;Adaptee&lt;/code&gt; is completely independent of the
other classes and is oblivious to any naming conventions or signatures that
they have.&lt;/p&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;Lets explore how we should use the Adapter Design Pattern to adopt two
incompatible payment systems and make them available for our customers. Assume
that we are building system that should support &lt;code&gt;PayPal&lt;/code&gt; and &lt;code&gt;Bank&lt;/code&gt; payments.
In addition, we are consuming two external libraries that handles each of this
payment methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;package paypal

import (
	&amp;quot;errors&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;regexp&amp;quot;
)

var mailRegexp = regexp.MustCompile(`^[a-z0-9._%+\-]+@[a-z0-9.\-]+\.[a-z]{2,4}$`)

// Money of PayPal transactions
type Money struct {
	// Amount
	Amount float64
	// Currency for that amount
	Currency string
}

// Payment in PayPal
type Payment struct {
	// APIKey is the PayPal API key
	APIKey string
}

// Send money
func (*Payment) Send(senderEmail, recipientEmail string, money *Money) error {
	if !mailRegexp.MatchString(senderEmail) {
		return errors.New(&amp;quot;Invalid sender email address&amp;quot;)
	}

	if !mailRegexp.MatchString(recipientEmail) {
		return errors.New(&amp;quot;Invalid recipient email address&amp;quot;)
	}

	if money == nil {
		return errors.New(&amp;quot;The money must be provided&amp;quot;)
	}

	if money.Amount &amp;lt;= 0 {
		return errors.New(&amp;quot;The amount cannot be negative&amp;quot;)
	}

	if money.Currency == &amp;quot;&amp;quot; {
		return errors.New(&amp;quot;The currency must be provided&amp;quot;)
	}

	fmt.Printf(&amp;quot;Send %f %s from %s to %s&amp;quot;, money.Amount, money.Currency, senderEmail, recipientEmail)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;package bank

import (
	&amp;quot;errors&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

// AccountType determines the type of bank account
type AccountType uint8

const (
	// AccountTypeCurrent is a current bank account
	AccountTypeCurrent AccountType = iota
	// AccountTypeSaving is a saving bank account
	AccountTypeSaving
)

// Account is a bank account
type Account struct {
	// Owner is the bank account owner
	Owner string
	// Email of the owner
	Email string
	// Balance is the bank account balance
	Balance float64
	// Currency of the account
	Currency string
}

// Transaction is the bank transaction
type Transaction struct {
	FromAccount *Account
	ToAccount   *Account
	Amount      float64
	Date        time.Time
	Reason      string
}

// Gateway for the Bank
type Gateway struct {
	// Token Key
	Token string
	// Accounts
	Accounts []*Account
}

// FindAccountByEmail finds a bank account
func (g *Gateway) FindAccountByEmail(email string) (*Account, error) {
	for _, account := range g.Accounts {
		if account.Email == email {
			return account, nil
		}
	}
	return nil, errors.New(&amp;quot;Account Not Found&amp;quot;)
}

// ProcessTransaction processes a bank transaction
func (g *Gateway) ProcessTransaction(t *Transaction) error {
	if t.FromAccount == nil {
		return errors.New(&amp;quot;FromAccount is missing&amp;quot;)
	}
	if t.ToAccount == nil {
		return errors.New(&amp;quot;ToAccount is missing&amp;quot;)
	}

	if t.Reason == &amp;quot;&amp;quot; {
		return errors.New(&amp;quot;Reason is not provided&amp;quot;)
	}

	if t.Amount &amp;lt;= 0 {
		return errors.New(&amp;quot;Invalid amount&amp;quot;)
	}

	if t.Amount &amp;gt; t.FromAccount.Balance {
		return errors.New(&amp;quot;Insufficient funds&amp;quot;)
	}

	fmt.Printf(&amp;quot;Transfered %f %s from %s to %s at %v&amp;quot;, t.Amount,
		t.FromAccount.Currency, t.FromAccount.Owner, t.ToAccount.Owner, t.Date)

	t.FromAccount.Balance -= t.Amount
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are developing a shopping card that should work with different payment methods:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Checkouter checkouts order
type Payment interface {
	// Pay from email to email this amount
	Pay(fromEmail, toEmail string, amount float64) error
}

// Item in the shopping card
type Item struct {
	// Name of the item
	Name string
	// Price of the item
	Price float64
}

// ShoppingCard in online store
type ShoppingCard struct {
	// Items im the ShoppingCard
	Items []*Item
	// PaymentMethod selected
	PaymentMethod Payment
	// ShopEmailAddress address of the shop
	ShopEmailAddress string
}

// Checkout checkouts a shopping card
func (c *ShoppingCard) Checkout(payeeEmail string) error {
	var total float64

	for _, item := range c.Items {
		total += item.Price
	}

	return c.PaymentMethod.Pay(payeeEmail, c.ShopEmailAddress, total)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you might see, the Bank API and PayPal API cannot be used as different
payment options in the &lt;code&gt;ShoppingCard&lt;/code&gt; object due to their different signatures.&lt;/p&gt;

&lt;p&gt;In order to adopt them we should implement an adapters that obey the &lt;code&gt;Payment&lt;/code&gt;
interface.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;BankAdapter&lt;/code&gt; adapts the bank package API by wrapping &lt;code&gt;bank.Gateway&lt;/code&gt;
struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// BankAdapter adapts bank API
type BankAdapter struct {
	// Gateway of the bank
	Gateway *bank.Gateway
}

// Pay from email to email this amount
func (b *BankAdapter) Pay(fromEmail, toEmail string, amount float64) error {
	fromAccount, err := b.Gateway.FindAccountByEmail(fromEmail)
	if err != nil {
		return err
	}

	toAccount, err := b.Gateway.FindAccountByEmail(toEmail)
	if err != nil {
		return err
	}

	t := &amp;amp;bank.Transaction{
		FromAccount: fromAccount,
		ToAccount:   toAccount,
		Amount:      amount,
		Date:        time.Now(),
		Reason:      &amp;quot;Payment to Online Store&amp;quot;,
	}

	return b.Gateway.ProcessTransaction(t)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;PayPal&lt;/code&gt; API is adopted by &lt;code&gt;PayPalAdapter&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// PayPalAdapter adapts PayPal API
type PayPalAdapter struct {
	Payment *paypal.Payment
}

// Pay from email to email this amount
func (p *PayPalAdapter) Pay(fromEmail, toEmail string, amount float64) error {
	return p.Payment.Send(fromEmail, toEmail, &amp;amp;paypal.Money{Amount: amount, Currency: &amp;quot;USD&amp;quot;})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;The Adapter Pattern&lt;/code&gt; is used wherever there is code to be wrapped up and
redirected to a different implementation.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;But How Much the &lt;code&gt;Adapter&lt;/code&gt; Should Do?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If the &lt;code&gt;Target&lt;/code&gt; and &lt;code&gt;Adaptee&lt;/code&gt; has similarities then the adapter has just to
delegate the requests from the Target to the Adaptee. If &lt;code&gt;Target&lt;/code&gt; and &lt;code&gt;Adaptee&lt;/code&gt;
are not similar, then the adapter might have to convert the data structures
between those and to implement the operations required by the Target but not
implemented by the Adaptee.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
