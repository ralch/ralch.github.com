<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/categories/tools/index.xml</link>
    <language>en-us</language>
    <author>Svetlin Ralchev</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Develop code generation tool for Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-code-generation-tool-implementation/</link>
      <pubDate>Sat, 31 Oct 2015 08:41:39 &#43;0100</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-code-generation-tool-implementation/</guid>
      <description>

&lt;p&gt;In my previous blog post, we discussed one of my favourite code generation tools
for Go. We found that they can be used to automate our trivial development tasks
or even introduce features like generics and queries. Lets explore how to
create our own tool.&lt;/p&gt;

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;The Go generate subcommand is a program that scans for special comments in your
Go source code. The comment declares a command that should be executed. The
tools is not part of Go build toolbelt. Usually it&amp;rsquo;s used by packaged
developers.&lt;/p&gt;

&lt;p&gt;This is the format of &lt;code&gt;go:generate&lt;/code&gt; comments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate &amp;lt;subcommand&amp;gt; &amp;lt;arguments&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After identifying all &lt;code&gt;go:generate&lt;/code&gt; comments it will execute the specified
commands.&lt;/p&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;We will build a command line tool that generates an implementation of
&lt;a href=&#34;https://golang.org/pkg/io/#WriterTo&#34;&gt;io.WriterTo&lt;/a&gt; interface for concrete type
and format.&lt;/p&gt;

&lt;p&gt;Lets name the tool &lt;code&gt;wordsmith&lt;/code&gt;. Note that in the sample we will use only &lt;code&gt;json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;io.WriterTo&lt;/code&gt; provides a function that writes data to a writer. The return value
n is the number of bytes written. Any error encountered during the write is
also returned:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type WriterTo interface {
        WriteTo(w Writer) (n int64, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets have a Point struct that is annotated with special &lt;code&gt;go:generate&lt;/code&gt; comment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Point struct {
	X float64
	Y float64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we implement the funcationality manually, we should end up with the following
code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (obj Point) WriteTo(writer io.Writer) (int64, error) {
	data, err := json.Marshal(&amp;amp;obj)
	if err != nil {
		return 0, err
	}
	length, err := writer.Write(data)
	return int64(length), err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can trainsform it into a &lt;code&gt;text/template&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package {{ .PackageName }}

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;io&amp;quot;
)

func ({{ .Object }} {{ .Type }}) WriteTo(writer io.Writer) (int64, error) {
  data, err := json.Marshal({{ .MarshalObject }})
  if err != nil {
  	return 0, err
  }
  length, err := writer.Write(data)
  return int64(length), err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;wordsmith&lt;/code&gt; generation tools is a command line application that has the
following arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pointer&lt;/code&gt; determines whether a type is a pointer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt; defines the name of the type that implements &lt;code&gt;io.WriterTo&lt;/code&gt; interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package&lt;/code&gt; defines the package that contains this type&lt;/li&gt;
&lt;li&gt;&lt;code&gt;format&lt;/code&gt; defines the serialization format that &lt;code&gt;io.WriterTo&lt;/code&gt; is providing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The function initial reads the arguments, locates the package directory and
creates the output file in the following format &lt;code&gt;&amp;lt;type_name&amp;gt;_writer.go&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	typePointer := flag.Bool(&amp;quot;pointer&amp;quot;, false, &amp;quot;Determines whether a type is a pointer or not&amp;quot;)
	typeName := flag.String(&amp;quot;type&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Type that hosts io.WriterTo interface implementation&amp;quot;)
	packageName := flag.String(&amp;quot;package&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Package name&amp;quot;)
	format := flag.String(&amp;quot;format&amp;quot;, &amp;quot;json&amp;quot;, &amp;quot;Encoding format&amp;quot;)

	flag.Parse()

	if *typeName == &amp;quot;&amp;quot; || *format != &amp;quot;json&amp;quot; {
		flag.Usage()
		return
	}

	pkgDir, err := packageDir(*packageName)
	if err != nil {
		panic(err)
	}

	outputFile := formatFileName(*typeName)
	writer, err := os.Create(filepath.Join(pkgDir, outputFile))
	if err != nil {
		panic(err)
	}
	defer writer.Close()

	generator := &amp;amp;Generator{Format: JSON}

	m := metadata(*typeName, *typePointer, pkgDir)
	if err := generator.Generate(writer, m); err != nil {
		panic(err)
	}

	fmt.Printf(&amp;quot;Generated %s %s\n&amp;quot;, *format, outputFile)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;wordsmith.Generator&lt;/code&gt; type is responsible to execute the text template and
generate the output file. It instaciates text template object from the template
file and substitute it with the &lt;code&gt;Metadata&lt;/code&gt; object properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Metadata struct {
	PackageName   string
	Object        string
	MarshalObject string
	Type          string
}

type Generator struct {
	Format Format
}

func (g *Generator) Generate(writer io.Writer, metadata Metadata) error {
	tmpl, err := g.template()
	if err != nil {
		return nil
	}

	return tmpl.Execute(writer, metadata)
}

func (g *Generator) template() (*template.Template, error) {
	if g.Format != JSON {
		return nil, errors.New(&amp;quot;Unsupported format&amp;quot;)
	}

	resource, err := Asset(&amp;quot;templates/writeto_json.tmpl&amp;quot;)
	if err != nil {
		return nil, err
	}

	tmpl := template.New(&amp;quot;template&amp;quot;)
	return tmpl.Parse(string(resource))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can read more about text templates in &lt;a href=&#34;https://golang.org/pkg/text/template/&#34;&gt;the official golang
documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;wordsmith&lt;/code&gt; can be used from command line prompt or by annotating &lt;code&gt;Point&lt;/code&gt;
struct with the following comment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate wordsmith -type=Point -format=json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following command identifies the &lt;code&gt;go:generate comment&lt;/code&gt; and executes
declared &lt;code&gt;wordsmith&lt;/code&gt; submcommand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// it scans all
$ go generate ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use the download the full source code from &lt;a href=&#34;http://github.com/svett/wordsmith&#34;&gt;github&lt;/a&gt;
or install it immediatelly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/svett/wordsmith
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;I am looking forward to see more tools in the Go ecosystem. Hopefully this
blog post will encourage more go developers to build such a tools that will boost
our productivity.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang code inspection tools</title>
      <link>http://blog.ralch.com/tutorial/golang-tools-inspection/</link>
      <pubDate>Sun, 13 Sep 2015 08:55:41 &#43;0100</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-tools-inspection/</guid>
      <description>

&lt;p&gt;As a software engineer, you always try to improve the quality of your programs.
We are looking for the best software development practices and TDD techniques.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Have no fear of perfection - you&#39;ll never reach it.&amp;quot;
― Salvador Dalí
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this article we will explore different code inspection tools in &lt;code&gt;Go&lt;/code&gt; ecosystem.
We will increase our code quality and engineering skills by running tools
that will do analysis on our code base and report the suspicious parts of it.&lt;/p&gt;

&lt;h2 id=&#34;govet&#34;&gt;Govet&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Vet&lt;/code&gt; does analysis on Go source code and reports suspicious constructs.
It uses heuristics that do not guarantee all reports are genuine problems.
&lt;code&gt;Vet&lt;/code&gt; can find errors not caught by the compilers.&lt;/p&gt;

&lt;p&gt;It can be invoked in three different ways:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// for go package
$ go tool vet package/path/name
// for files
$ go tool vet source/directory/*.go
// for directory
$ go tool vet source/directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What should be analysed can be controlled with these flags (extraced from help doc):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-all&lt;/code&gt; check everything; disabled if any explicit check is requested (default true)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-asmdecl&lt;/code&gt; check assembly against Go declarations (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-assign&lt;/code&gt; check for useless assignments (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-atomic&lt;/code&gt; check for common mistaken usages of the sync/atomic package (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-bool&lt;/code&gt; check for mistakes involving boolean operators (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-buildtags&lt;/code&gt; check that +build tags are valid (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-composites&lt;/code&gt; check that composite literals used field-keyed elements (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-compositewhitelist&lt;/code&gt; use composite white list; for testing only (default true)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-copylocks&lt;/code&gt; check that locks are not passed by value (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-methods&lt;/code&gt; check that canonically named methods are canonically defined (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-nilfunc&lt;/code&gt; check for comparisons between functions and nil (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-printf&lt;/code&gt; check printf-like invocations (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-printfuncs&lt;/code&gt; string comma-separated list of print function names to check&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-rangeloops&lt;/code&gt; check that range loop variables are used correctly (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-shadow&lt;/code&gt; check for shadowed variables (experimental; must be set explicitly) (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-shadowstrict&lt;/code&gt; whether to be strict about shadowing; can be noisy&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-shift&lt;/code&gt; check for useless shifts (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-structtags&lt;/code&gt; check that struct field tags have canonical format and apply to exported fields as needed (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-tags&lt;/code&gt; string comma-separated list of build tags to apply when parsing&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-test&lt;/code&gt; for testing only: sets -all and -shadow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-unreachable&lt;/code&gt; check for unreachable code (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-unsafeptr&lt;/code&gt; check for misuse of unsafe.Pointer (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-unusedfuncs&lt;/code&gt; string comma-separated list of functions whose results must be used (default &amp;ldquo;errors.New,fmt.Errorf,fmt.Sprintf,fmt.Sprint,sort.Reverse&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-unusedresult&lt;/code&gt; check for unused result of calls to functions in -unusedfuncs list and methods in -unusedstringmethods list (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-unusedstringmethods&lt;/code&gt; string comma-separated list of names of methods of type func() string whose results must be used (default &amp;ldquo;Error,String&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets use this code snippet from &lt;a href=&#34;https://twitter.com/francesc&#34;&gt;@francesc&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// extracted from tweet: https://twitter.com/francesc/status/491699441506586627
// filename: sample.go
package main

import &amp;quot;fmt&amp;quot;

func main() {
	a := 0
	if a != 1 || a != 2 { 
		 a++ 
	}

	fmt.Printf(&amp;quot;a = %s\n&amp;quot;, a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see the tool in action:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go tool vet sample.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Vet&lt;/code&gt; reports two suspicious constructions. First it reports that the if-condition
is suspicious. It&amp;rsquo;s always &lt;code&gt;true&lt;/code&gt; since cannot be both. The second warning reports
that &lt;code&gt;%s&lt;/code&gt; is used with &lt;code&gt;integer&lt;/code&gt; type instead of &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sample.go:10: suspect or: a != 1 || a != 2
sample.go:14: arg a for printf verb %s of wrong type: int
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;golint&#34;&gt;Golint&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/golang/lint&#34;&gt;Golint&lt;/a&gt; differs from &lt;code&gt;gofmt&lt;/code&gt; and &lt;code&gt;govet&lt;/code&gt;. It prints out style mistakes.
&lt;code&gt;Golint&lt;/code&gt; is concerned with coding style. It is in use at Google, and it seeks
to match the accepted style of the open source Go project.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Golint&lt;/code&gt; make suggestions regarding source code. It is not perfect,
and has both false positives and false negatives. Do not consider its output as a truth.
It will never be trustworthy enough to be enforced automatically as part of a build process.&lt;/p&gt;

&lt;h4 id=&#34;installation&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;go get -u github.com/golang/lint/golint
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage&#34;&gt;Usage&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// analysis a particular package
$ golint package
// analysis a particular directory
$ golint directory 
// analyses a particualr files
$ golint files 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets &lt;code&gt;lint&lt;/code&gt; the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: hr.go
package hr

import &amp;quot;errors&amp;quot;

const MaxAge int = 70

type Person struct {
	Name string
	Age  int
}

func NewPerson(name string) (*Person, error) {
	if name == &amp;quot;&amp;quot; {
		return nil, errors.New(&amp;quot;Name is required&amp;quot;)
	} else {
		return &amp;amp;Person{Name: name}, nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The command tool give us the following sugestion to improve our source code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hr.go:5:6: exported type Person should have comment or be unexported
hr.go:9:1: exported function NewPerson should have comment or be unexported
hr.go:12:9: if block ends with a return statement, so drop this else and outdent its block
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Neat. Isn&amp;rsquo;t it?&lt;/p&gt;

&lt;h2 id=&#34;errcheck&#34;&gt;Errcheck&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://github.com/kisielk/errcheck&#34;&gt;errcheck&lt;/a&gt; command tools is a program that checks whether a source code has
unhandled errors.&lt;/p&gt;

&lt;h4 id=&#34;installation-1&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/kisielk/errcheck
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-1&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;The following flags can control the tool behavior (extracted from help doc):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-abspath&lt;/code&gt; print absolute paths to files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-asserts&lt;/code&gt; if true, check for ignored type assertion results&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-blank&lt;/code&gt; if true, check for errors assigned to blank identifier. By default is false.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ignore&lt;/code&gt; value comma-separated list of pairs in pkg:regex format.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ignorepkg&lt;/code&gt; string comma-separated list of package paths to ignore&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-tags&lt;/code&gt; value space-separated list of build tags to include (default &amp;ldquo;&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-verbose&lt;/code&gt; produce more verbose logging&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets have the following snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: logger.go
package logger 

import &amp;quot;os&amp;quot;

func Log(path, data string) {
	file, _ := os.Open(path)
	file.Write([]byte(data))
	file.Close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets do error handling analysis with &lt;code&gt;errcheck&lt;/code&gt; tool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Note that analyses of _ errors is skipped by default.
// We enable that by providing -blank flag.
$ errcheck -blank app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following lines are reported as problematic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web/logger.go:6:8        file, _ := os.Open(path)
web/logger.go:7:12       file.Write([]byte(data))
web/logger.go:8:12       file.Close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;safesql&#34;&gt;SafeSQL&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/stripe/safesql&#34;&gt;SafeSQL&lt;/a&gt; is a static analysis command line
tool that protects against &lt;a href=&#34;https://en.wikipedia.org/wiki/SQL_injection&#34;&gt;SQL injections&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;installation-2&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/stripe/safesql
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-2&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;If SafeSQL passes, your application is safe from SQL injections, however there
are many safe programs which SafeSQL will declare potentially unsafe. There are
false positives due to the fact that &lt;code&gt;SafeSQL&lt;/code&gt; does not recursively trace down
query arguments through every function. Second there are many SQL statement to
represent compile time constants required for the static analysis algorithm.&lt;/p&gt;

&lt;p&gt;Lets see the tool in action with this code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package database

import (
	&amp;quot;database/sql&amp;quot;
	&amp;quot;log&amp;quot;
)

func Status(username string) string {
	db, err := sql.Open(&amp;quot;mysql&amp;quot;, &amp;quot;user:password@tcp(127.0.0.1:3306)/hello&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}

	defer db.Close()
	sql := &amp;quot;SELECT * FROM user WHERE username=&#39;&amp;quot; + username + &amp;quot;&#39;&amp;quot;
	row := db.QueryRow(sql)

	var isLogged bool
	row.Scan(&amp;amp;isLogged)
	if isLogged {
		return &amp;quot;online&amp;quot;
	}

	return &amp;quot;offline&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It reports the following SQL injection:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Found 1 potentially unsafe SQL statements:
- /$GOPATH/db/database.go:16:20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It gives the following recommendation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Please ensure that all SQL queries you use are compile-time constants.
You should always use parameterized queries or prepared statements
instead of building queries from strings.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;defercheck&#34;&gt;Defercheck&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/opennota/check/&#34;&gt;Defercheck&lt;/a&gt; is command tool that checks for repeating &lt;code&gt;defer&lt;/code&gt; statements.&lt;/p&gt;

&lt;h4 id=&#34;installation-3&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/opennota/check/cmd/defercheck
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-3&#34;&gt;Usage&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ defercheck go/parser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It reports the following suspicious defer statement in parser package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/.../go/parser/parser.go:1929: Repeating defer p.closeScope() inside function parseSwitchStmt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;structcheck&#34;&gt;Structcheck&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/opennota/check/&#34;&gt;Structcheck&lt;/a&gt; is command tool that checks for unused field in structs.&lt;/p&gt;

&lt;h4 id=&#34;installation-4&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/opennota/check/cmd/structcheck
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-4&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;Lets check the &lt;code&gt;hr&lt;/code&gt; codesnippet that we used previously.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ structcheck -e hr 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Available command line flags are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt; Count assignments only&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; Report exported fields&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt; Load test files too&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It reports that the &lt;code&gt;Age&lt;/code&gt; field of &lt;code&gt;Person&lt;/code&gt; struct is unused:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hr: /$GOPATH/src/hr/hr.go:7:2: hr/hr.Person.Age
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;varcheck&#34;&gt;Varcheck&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/opennota/check/&#34;&gt;Varcheck&lt;/a&gt; command is doing the same analysis as &lt;code&gt;Structcheck&lt;/code&gt; but on global
variables and constants.&lt;/p&gt;

&lt;h4 id=&#34;installation-5&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/opennota/check/cmd/varcheck
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-5&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;Lets inspect the &lt;code&gt;hr&lt;/code&gt; package again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// -e Report exported variables and constants
$ varcheck -e hr 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It finds that the &lt;code&gt;Age&lt;/code&gt; constant is not used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hr: /$GOPATH/src/hr/hr.go:5:7: MaxAge
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/go/ssa&#34;&gt;Static single-assignment package&lt;/a&gt;
provides a very powerful framework for code analysis. It gives the opportunity
to build different tools that may increase the code quality and durability of
every &lt;code&gt;Go&lt;/code&gt; program. I am looking forward to see more and more command tools
that will bring our source code to the next level.&lt;/p&gt;

&lt;p&gt;The previous articles regarding tools in &lt;code&gt;Go&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.ralch.com/tutorial/golang-tools-refactoring/&#34;&gt;Golang refactoring tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.ralch.com/tutorial/golang-tools-comprehension/&#34;&gt;Golang code comprehension tools&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang code comprehension tools</title>
      <link>http://blog.ralch.com/tutorial/golang-tools-comprehension/</link>
      <pubDate>Sun, 06 Sep 2015 08:52:51 &#43;0100</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-tools-comprehension/</guid>
      <description>

&lt;p&gt;Software engineers spend a greater part of time reading and understanding programs.
Indeed, most of the time it takes to develop a program is spent reading it and
making logical conclusion about what it does.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; programmers are no exception. Thanks to &lt;a href=&#34;http://blog.ralch.com/tutorial/golang-tools-refactoring/&#34;&gt;gofmt&lt;/a&gt;
they should not worry about source code formatting. The machines are
better suited to analyse source code and accomplish comprehension tasks than us.&lt;/p&gt;

&lt;p&gt;In this article we will explore several of &lt;code&gt;Go&lt;/code&gt; comprehension tools that are
responsible for locating definitions, ascertaining types of expressions, deducing implementation
relation, computing method sets, finding callers/callees, jumping through channels,
understanding aliasing.&lt;/p&gt;

&lt;h2 id=&#34;oracle&#34;&gt;Oracle&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;oralce&lt;/code&gt; is a source analysis tool that answers question about your Go source code.
It is installed by executing this command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get golang.org/x/tools/cmd/oracle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;-pos&lt;/code&gt; flag is always required. It defines the current cursor position that
should be analysed. The expected value is a bytes offset from the beginning of
the file.&lt;/p&gt;

&lt;p&gt;These are the subcommands that determines the query to perform:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;callees&lt;/code&gt; show possible targets of selected function call&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callers&lt;/code&gt; show possible callers of selected function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callstack&lt;/code&gt; show path from callgraph root to selected function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;definition&lt;/code&gt; show declaration of selected identifier&lt;/li&gt;
&lt;li&gt;&lt;code&gt;describe&lt;/code&gt; describe selected syntax: definition, methods, etc&lt;/li&gt;
&lt;li&gt;&lt;code&gt;freevars&lt;/code&gt; show free variables of selection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;implements&lt;/code&gt; show relation for selected type or method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;peers&lt;/code&gt; show send/receive corresponding to selected channel op&lt;/li&gt;
&lt;li&gt;&lt;code&gt;referrers&lt;/code&gt; show all refs to entity denoted by selected identifier&lt;/li&gt;
&lt;li&gt;&lt;code&gt;what&lt;/code&gt; show basic information about the selected syntax node&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;-format&lt;/code&gt; flag set the output format to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;plain&lt;/code&gt; an editor-friendly format in which every line of output&lt;/li&gt;
&lt;li&gt;&lt;code&gt;json&lt;/code&gt; structured data in JSON syntax.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xml&lt;/code&gt; structured data in XML syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall, the tools provides an friendly interface for adopting it in different
development editor: &lt;a href=&#34;https://github.com/fatih/vim-go&#34;&gt;Vim&lt;/a&gt;, &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt;,
&lt;a href=&#34;https://atom.io&#34;&gt;Atom&lt;/a&gt;, IntelliJ and etc.&lt;/p&gt;

&lt;p&gt;Let see &lt;code&gt;oracle&lt;/code&gt; in action:&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/F0ZLIxKWSYo&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;


&lt;h2 id=&#34;pythia&#34;&gt;Pythia&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Pythia&lt;/code&gt; is a browser based user interface for oracle. It is based on
the following packages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/oracle&#34;&gt;oracle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/godoc/static&#34;&gt;godoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Pythia&lt;/code&gt; is installed with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/fzipp/pythia
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;pythia&lt;/code&gt; command tool now can be found in &lt;code&gt;$GOPATH/bin/pythia&lt;/code&gt;. A specific
package can be opened with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pythia net/http 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default the command opens your default browser:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/golang-pythia-in-action.png&#34; alt=&#34;Pythia in Action&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;This can be disabled with &lt;code&gt;-open&lt;/code&gt; flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pythia -open=false net/http
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default listening port is &lt;code&gt;:8080&lt;/code&gt;. It can be changed via &lt;code&gt;-http&lt;/code&gt; flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pythia -http :9876 net/http
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The packages can be filtered out on their &lt;a href=&#34;http://blog.ralch.com/tutorial/golang-conditional-compilation/&#34;&gt;build tags&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pythia -tags=unix net/http
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;godepgraph&#34;&gt;Godepgraph&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Godepgraph&lt;/code&gt; is a program for generating a dependency graph of Go packages.
Use &lt;code&gt;go get&lt;/code&gt; command to install it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/kisielk/godepgraph
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usually the tool is combined with &lt;code&gt;dot&lt;/code&gt; command (graphviz CLI):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// this command will generate dependency graph as svg image
// -s ingores the builtin packages
// -horizontal layout the graphics horizontally
$ godepgraph -s -horizontal github.com/codegangsta/gin | dot -Tsvg -o gin-godepgraph.svg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The command above will produce the following graphics:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/golang-godepgraph.svg&#34; alt=&#34;Godepgraph in Action&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The &lt;code&gt;godepgraph&lt;/code&gt; tools can be controlled with these flags:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; show dependencies of packages in the Go standard library&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-horizontal&lt;/code&gt; lay out the dependency graph horizontally instead of vertically&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; string a comma-separated list of packages to ignore&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt; string a comma-separated list of prefixes to ignore&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt; ignore packages in the Go standard library&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt; include test packages&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-tags&lt;/code&gt; string a comma-separated list of build tags to consider satisfied during the build&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Even though Golang does not have dedicated development environment, software engineers
can be very product by adopting some of the comprehensive tools mentioned in this article.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang refactoring tools</title>
      <link>http://blog.ralch.com/tutorial/golang-tools-refactoring/</link>
      <pubDate>Sun, 30 Aug 2015 12:41:34 &#43;0100</pubDate>
      <author>Svetlin Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-tools-refactoring/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt; language provides many useful tools as part of its
development eco system. We will explore most of them in the upcoming blog posts.
But in the article lets focus on refactoring tools.&lt;/p&gt;

&lt;h2 id=&#34;gofmt&#34;&gt;Gofmt&lt;/h2&gt;

&lt;p&gt;In average programming languages developers can adapt to different formatting
styles. Common problem is how to approach unknown code base without a long
prescriptive style guide.&lt;/p&gt;

&lt;p&gt;Go takes an unusual approach and keep this responsibility to format the source code
for you. The &lt;code&gt;gofmt&lt;/code&gt; program (available as &lt;code&gt;go fmt&lt;/code&gt;, which examines
on the package level rather than source file level) reads a Go syntax and reformat
your program in a standard coding style. In addition, it provides some additional
refactoring capabilities, which will explore in detail.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The -w flag overwrites the files instead of prints out the result on the screen
$ gofmt -w message.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It formats the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: message.go
package message
import &amp;quot;fmt&amp;quot;
func FormatMessage(name string) string{
if len(name) == 0 { return &amp;quot;Welcome&amp;quot; } else { return fmt.Sprintf(&amp;quot;Hi, %s&amp;quot;, name) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: message.go
package message

import &amp;quot;fmt&amp;quot;

func FormatMessage(name string) string {
	if len(name) == 0 {
		return &amp;quot;Welcome&amp;quot;
	} else {
		return fmt.Sprintf(&amp;quot;Hi, %s&amp;quot;, name)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that &lt;code&gt;gofmt&lt;/code&gt; uses tabs for indentation and
blanks for alignment.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The code is reformatted to obey all &lt;code&gt;Go&lt;/code&gt; coding style standards. It does not rename
any variables and functions. There is a tool that do static analyses on your code.
We will talk about it in one of the next articles.&lt;/p&gt;

&lt;p&gt;These are the flags supported by &lt;code&gt;gofmt&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; prints diffs to standard out when file formatting is changed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; print all errors&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt; prints the filename to standard out when file formatting is changed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; applies the rewrite rule to the source before reformatting.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt; simplifies code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt; overwrites file with its formatted version&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the next two paragraphs we will explore how to simplify and apply rewrites rules
to a source code.&lt;/p&gt;

&lt;p&gt;Simplifing source code is applied when &lt;code&gt;-s&lt;/code&gt; flag is presented. It improves the
code readability by replacing blocks of code with their sipliefied syntax version.&lt;/p&gt;

&lt;p&gt;Executing &lt;code&gt;go fmt -s -w transport.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: transport.go
package transport

import &amp;quot;fmt&amp;quot;

type Endpoint struct {
	Protocol string
	Host     string
	Port     int
}

var endpoints []Endpoint = []Endpoint{
	Endpoint{
		Protocol: &amp;quot;HTTP&amp;quot;,
		Host:     &amp;quot;localhost&amp;quot;,
		Port:     80},
	Endpoint{
		Protocol: &amp;quot;SSH&amp;quot;,
		Host:     &amp;quot;10.10.5.9.xip.io&amp;quot;,
		Port:     22}}

func ListEndpoints(startIndex int) {
	for index, _ := range endpoints[startIndex:len(endpoints)] {
		endpoint := endpoints[index]
		fmt.Printf(&amp;quot;Priority: %d Procotol: %s Address: %s:%d\n&amp;quot;,
			index, endpoint.Protocol, endpoint.Host, endpoint.Port)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The package will be simplified to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: transport.go
package transport

import &amp;quot;fmt&amp;quot;

type Endpoint struct {
	Protocol string
	Host     string
	Port     int
}

var endpoints []Endpoint = []Endpoint{
	{Protocol: &amp;quot;HTTP&amp;quot;,
		Host: &amp;quot;localhost&amp;quot;,
		Port: 80},
	{Protocol: &amp;quot;SSH&amp;quot;,
		Host: &amp;quot;10.10.5.9.xip.io&amp;quot;,
		Port: 22}}

func ListEndpoints(startIndex int) {
	for index := range endpoints[startIndex:] {
		endpoint := endpoints[index]
		fmt.Printf(&amp;quot;Priority: %d Procotol: %s Address: %s:%d\n&amp;quot;,
			index, endpoint.Protocol, endpoint.Host, endpoint.Port)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are the applied rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An array, slice, or map composite literal of the form &lt;code&gt;[]T{T{}, T{}}&lt;/code&gt;
will be simplified to &lt;code&gt;[]T{{}, {}}&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A slice expression of the form &lt;code&gt;s[a:len(s)]&lt;/code&gt; will be simplified to &lt;code&gt;s[a:]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A range of the form &lt;code&gt;for x, _ = range v {...}&lt;/code&gt; will be simplified to &lt;code&gt;for x = range v {...}&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A range of the form &lt;code&gt;for _ = range v {...}&lt;/code&gt; will be simplified to &lt;code&gt;for range v {...}&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To define specified rewrite rule the &lt;code&gt;-r&lt;/code&gt; flag must be used. It should be in
the following format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pattern -&amp;gt; replacement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both pattern and replacement must be valid &lt;code&gt;Go&lt;/code&gt; expressions. The pattern serves
as wildcards matching arbitrary sub-expressions. They will be substituted for
the same identifiers in the replacement.&lt;/p&gt;

&lt;p&gt;Lets rename &lt;code&gt;Endpoint&lt;/code&gt; struct to &lt;code&gt;Server&lt;/code&gt; in &lt;code&gt;transport&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gofmt -r &#39;Endpoint -&amp;gt; Server&#39; -w transport.go
$ gofmt -r &#39;endpoints -&amp;gt; servers&#39; -w transport.go
$ gofmt -r &#39;ListEndpoints -&amp;gt; ListServers&#39; -w transport.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result of this operation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: transport.go
package transport

import &amp;quot;fmt&amp;quot;

type Server struct {
	Protocol string
	Host     string
	Port     int
}

var servers []Server = []Server{
	{Protocol: &amp;quot;HTTP&amp;quot;,
		Host: &amp;quot;localhost&amp;quot;,
		Port: 80},
	{Protocol: &amp;quot;SSH&amp;quot;,
		Host: &amp;quot;10.10.5.9.xip.io&amp;quot;,
		Port: 22}}

func ListServers(startIndex int) {
	for index := range servers[startIndex:] {
		endpoint := servers[index]
		fmt.Printf(&amp;quot;Priority: %d Procotol: %s Address: %s:%d\n&amp;quot;,
			index, endpoint.Protocol, endpoint.Host, endpoint.Port)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gorename&#34;&gt;Gorename&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;gorename&lt;/code&gt; is another tool for code refactoring. It command performs precise
type-safe renaming of identifiers in Go source code. It is installed with
the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get golang.org/x/tools/refactor/rename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets use the tool with the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// package: university
package main

import &amp;quot;fmt&amp;quot;

type Student struct {
	Firstname string
	Surename  string
}

func (s *Student) Fullname() string {
	return fmt.Sprintf(&amp;quot;%s %s&amp;quot;, s.Firstname, s.Surename)
}

func main() {
	students := []Student{
		{Firstname: &amp;quot;John&amp;quot;,
			Surename: &amp;quot;Freeman&amp;quot;},
		{Firstname: &amp;quot;Jack&amp;quot;,
			Surename: &amp;quot;Numan&amp;quot;},
	}

	for _, s := range students {
		fmt.Println(s.Fullname())
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Renaming &lt;code&gt;Fullname&lt;/code&gt; function of &lt;code&gt;Student&lt;/code&gt; struct to &lt;code&gt;String&lt;/code&gt; can be done by
executing &lt;code&gt;gorename&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gorename -from &#39;&amp;quot;university&amp;quot;.Student.Fullname&#39; -to String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-from&lt;/code&gt; flag must obey the following format specifies the object to rename
using a query notation like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;encoding/json&amp;quot;.Decoder.Decode        method of package-level named type
(*&amp;quot;encoding/json&amp;quot;.Decoder).Decode     ditto, alternative syntax
&amp;quot;encoding/json&amp;quot;.Decoder.buf           field of package-level named struct type
&amp;quot;encoding/json&amp;quot;.HTMLEscape            package member (const, func, var, type)
&amp;quot;encoding/json&amp;quot;.Decoder.Decode::x     local object x within a method
&amp;quot;encoding/json&amp;quot;.HTMLEscape::x         local object x within a function
&amp;quot;encoding/json&amp;quot;::x                    object x anywhere within a package
json.go::x                            object x within file json.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-to&lt;/code&gt; flag defines the new name of the object.&lt;/p&gt;

&lt;h2 id=&#34;eg&#34;&gt;Eg&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Eg&lt;/code&gt; command is a tool that implements example-based refactoring of expressions.
The transformation is specified as a Go file defining two functions,
&lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; of identical types. The parameters of both functions are
wildcards that may match any expression assignable to that type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package P
import ( &amp;quot;errors&amp;quot;; &amp;quot;fmt&amp;quot; )
// specifies a match pattern like:
func before(s string) error { return fmt.Errorf(&amp;quot;%s&amp;quot;, s) }
// specifies its replacement like:
func after(s string)  error { return errors.New(s) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tool analyses all Go code in the packages specified by the
arguments, replacing all occurrences of the pattern with the
substitution.&lt;/p&gt;

&lt;p&gt;Lets apply the below example to &lt;code&gt;university&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: stringfix.go
package P

import &amp;quot;fmt&amp;quot;

// specifies a match pattern like:
func before(x, y string) string { return fmt.Sprintf(&amp;quot;%s %s&amp;quot;, x, y) }

// specifies its replacement like:
func after(x, y string) string { return x + &amp;quot; &amp;quot; + y }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do that we should execute &lt;code&gt;eg&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// -t specifies the template file
// -w specifies that the matched files must be overwritten
$ eg -t stringfix.go -w  -- university
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tool changes the implementation of &lt;code&gt;String&lt;/code&gt; function of &lt;code&gt;Student&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// package: university
// struct: Student
// filename: main.go
func (s *Student) Fullname() string {
	return s.Firstname + &amp;quot; &amp;quot; + s.Surename
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As part of our job is not only to develop new features, but also improve
existing code base. &lt;code&gt;Gofmt&lt;/code&gt;, &lt;code&gt;gorename&lt;/code&gt; and &lt;code&gt;eg&lt;/code&gt; are tools that can help to
boost the productivity and keep source code in well formatted shape
that fits the &lt;code&gt;Go&lt;/code&gt; coding style standard.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
