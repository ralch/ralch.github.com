<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software adventures and thoughts</title>
    <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://blog.ralch.com/categories/tutorial/index.xml</link>
    <language>en-us</language>
    <author>Svett Ralchev</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Errors handling in Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-handling-errors/</link>
      <pubDate>Thu, 10 Mar 2016 08:52:29 UTC</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-handling-errors/</guid>
      <description>

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; does not have an &lt;code&gt;Exception&lt;/code&gt; handling model as most of the main stream
languages. However, it uses the error interface type as the return type for any
error that is going to be returned from a function or method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;type error interface {
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is an interface type. An error variable represents any value
that can describe itself as a string. The most commonly-used error
implementation is in the &lt;a href=&#34;https://golang.org/pkg/errors/&#34;&gt;errors&lt;/a&gt; package.&lt;/p&gt;

&lt;p&gt;It can be instaciated in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;func DivideBy(divider float64) (float64, error) {
    if divider &amp;lt;= 0 {
        return 0, errors.New(&amp;quot;Divider cannot be zero or negative number.&amp;quot;)
    }
    // implementation
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;errors.New&lt;/code&gt; functions constructs an exported type &lt;code&gt;errorString&lt;/code&gt; that
implements the &lt;code&gt;Error&lt;/code&gt; interface:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;// Copyright 2011 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package errors implements functions to manipulate errors.
package errors

// New returns an error that formats as the given text.
func New(text string) error {
	return &amp;amp;errorString{text}
}

// errorString is a trivial implementation of error.
type errorString struct {
	s string
}

func (e *errorString) Error() string {
	return e.s
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is pretty straighforward to implement your own error type that has additional
data.&lt;/p&gt;

&lt;p&gt;The error model in &lt;code&gt;Golang&lt;/code&gt; does not provide a way to find out, which function
returned the error. We should be aware and log the errors very carefully in
order to understand where this error occurred.&lt;/p&gt;

&lt;p&gt;Fortunately, the &lt;code&gt;Golang&lt;/code&gt; runtime provides a set of functions that we can use to
generate a stacktrace that we can trace down easily.&lt;/p&gt;

&lt;p&gt;In the following paragraphs, we will explore the Planatir
&lt;a href=&#34;https://github.com/palantir/stacktrace&#34;&gt;stacktrace&lt;/a&gt; package that does this for
us.&lt;/p&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h3&gt;

&lt;p&gt;The package captures a strategic places along the call stack and attaches relevant
contextual information like messages and variables. It is keeping stack traces
compact and maximally useful.&lt;/p&gt;

&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;In order to use the package, we should install it first by using the well known
&lt;code&gt;go get&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Bash&#34;&gt;$ go get github.com/palantir/stacktrace
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;The package provides a various functions to propagate and generate that
contextual information.&lt;/p&gt;

&lt;h5 id=&#34;error-propagation&#34;&gt;Error propagation&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;stacktrace.Propagate&lt;/code&gt; function replaces the usage of &lt;code&gt;fmt.Errorf&lt;/code&gt; function. It
wraps an error to include line number information. This is going to be your
most common stacktrace call.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;db, err := sql.Open(&amp;quot;postgres&amp;quot;, conninfo)
if err != nil {
   return stacktrace.Propagate(err, &amp;quot;Failed to connect %v&amp;quot;, conninfo)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;creating-errors&#34;&gt;Creating errors&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;stacktrace.NewError&lt;/code&gt; creates a new error that includes line number information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;if amount &amp;lt;= 0 {
    return stacktrace.NewError(&amp;quot;Expected amount %v to be positive number&amp;quot;, arg)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;error-codes&#34;&gt;Error Codes&lt;/h5&gt;

&lt;p&gt;Sometimes it&amp;rsquo;s useful to propagate an error code while unwinding the
stack. For instance, a RESTful API may use the error code to set the HTTP status
code. The type &lt;code&gt;stacktrace.ErrorCode&lt;/code&gt; is used to name the set of error codes
relevant to your application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;const (
    ConnectionTimeout = stacktrace.ErrorCode(iota)
		ConnectionLost
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The value &lt;code&gt;stacktrace.NoCode&lt;/code&gt; is equal to &lt;code&gt;math.MaxUint16&lt;/code&gt;, so avoid using
that. &lt;code&gt;NoCode&lt;/code&gt; is the default value of errors that does not have explicitly set
error code.&lt;/p&gt;

&lt;p&gt;You can use &lt;code&gt;stacktrace.PropagateWithCode&lt;/code&gt; and &lt;code&gt;stacktrace.NewErrorWithCode&lt;/code&gt; to
instaciated an error that has specific code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;db, err := sql.Open(&amp;quot;postgres&amp;quot;, conninfo)
if err != nil {
   return stacktrace.PropagateWithCode(err, ConnectionTimeout, &amp;quot;Failed to connect %v&amp;quot;, conninfo)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can extract the error code from the error by using &lt;code&gt;stacktrace.GetCode&lt;/code&gt;
function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Golang&#34;&gt;data, err := fetch()
if err != nil {
  code := stacktrace.GetCode(err)
	if code == ConnectionTimeout {
	   return nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;verdict&#34;&gt;Verdict&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;stacktrace&lt;/code&gt; package is very pleasant and easy to use. It comforms the Golang
idiomatic way of handling errors and provides us with additional contextual information
about the file and the line where the error occurred.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Develop code generation tool for Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-code-generation-tool-implementation/</link>
      <pubDate>Sat, 31 Oct 2015 08:41:39 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-code-generation-tool-implementation/</guid>
      <description>

&lt;p&gt;In my previous blog post, we discussed one of my favourite code generation tools
for Go. We found that they can be used to automate our trivial development tasks
or even introduce features like generics and queries. Lets explore how to
create our own tool.&lt;/p&gt;

&lt;h4 id=&#34;introduction&#34;&gt;Introduction&lt;/h4&gt;

&lt;p&gt;The Go generate subcommand is a program that scans for special comments in your
Go source code. The comment declares a command that should be executed. The
tools is not part of Go build toolbelt. Usually it&amp;rsquo;s used by packaged
developers.&lt;/p&gt;

&lt;p&gt;This is the format of &lt;code&gt;go:generate&lt;/code&gt; comments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate &amp;lt;subcommand&amp;gt; &amp;lt;arguments&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After identifying all &lt;code&gt;go:generate&lt;/code&gt; comments it will execute the specified
commands.&lt;/p&gt;

&lt;h4 id=&#34;implementation&#34;&gt;Implementation&lt;/h4&gt;

&lt;p&gt;We will build a command line tool that generates an implementation of
&lt;a href=&#34;https://golang.org/pkg/io/#WriterTo&#34;&gt;io.WriterTo&lt;/a&gt; interface for concrete type
and format.&lt;/p&gt;

&lt;p&gt;Lets name the tool &lt;code&gt;wordsmith&lt;/code&gt;. Note that in the sample we will use only &lt;code&gt;json&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;io.WriterTo&lt;/code&gt; provides a function that writes data to a writer. The return value
n is the number of bytes written. Any error encountered during the write is
also returned:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type WriterTo interface {
        WriteTo(w Writer) (n int64, err error)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets have a Point struct that is annotated with special &lt;code&gt;go:generate&lt;/code&gt; comment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Point struct {
	X float64
	Y float64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we implement the funcationality manually, we should end up with the following
code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (obj Point) WriteTo(writer io.Writer) (int64, error) {
	data, err := json.Marshal(&amp;amp;obj)
	if err != nil {
		return 0, err
	}
	length, err := writer.Write(data)
	return int64(length), err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can trainsform it into a &lt;code&gt;text/template&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package {{ .PackageName }}

import (
	&amp;quot;encoding/json&amp;quot;
	&amp;quot;io&amp;quot;
)

func ({{ .Object }} {{ .Type }}) WriteTo(writer io.Writer) (int64, error) {
  data, err := json.Marshal({{ .MarshalObject }})
  if err != nil {
  	return 0, err
  }
  length, err := writer.Write(data)
  return int64(length), err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;wordsmith&lt;/code&gt; generation tools is a command line application that has the
following arguments:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pointer&lt;/code&gt; determines whether a type is a pointer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt; defines the name of the type that implements &lt;code&gt;io.WriterTo&lt;/code&gt; interface&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package&lt;/code&gt; defines the package that contains this type&lt;/li&gt;
&lt;li&gt;&lt;code&gt;format&lt;/code&gt; defines the serialization format that &lt;code&gt;io.WriterTo&lt;/code&gt; is providing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The function initial reads the arguments, locates the package directory and
creates the output file in the following format &lt;code&gt;&amp;lt;type_name&amp;gt;_writer.go&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	typePointer := flag.Bool(&amp;quot;pointer&amp;quot;, false, &amp;quot;Determines whether a type is a pointer or not&amp;quot;)
	typeName := flag.String(&amp;quot;type&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Type that hosts io.WriterTo interface implementation&amp;quot;)
	packageName := flag.String(&amp;quot;package&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Package name&amp;quot;)
	format := flag.String(&amp;quot;format&amp;quot;, &amp;quot;json&amp;quot;, &amp;quot;Encoding format&amp;quot;)

	flag.Parse()

	if *typeName == &amp;quot;&amp;quot; || *format != &amp;quot;json&amp;quot; {
		flag.Usage()
		return
	}

	pkgDir, err := packageDir(*packageName)
	if err != nil {
		panic(err)
	}

	outputFile := formatFileName(*typeName)
	writer, err := os.Create(filepath.Join(pkgDir, outputFile))
	if err != nil {
		panic(err)
	}
	defer writer.Close()

	generator := &amp;amp;Generator{Format: JSON}

	m := metadata(*typeName, *typePointer, pkgDir)
	if err := generator.Generate(writer, m); err != nil {
		panic(err)
	}

	fmt.Printf(&amp;quot;Generated %s %s\n&amp;quot;, *format, outputFile)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;wordsmith.Generator&lt;/code&gt; type is responsible to execute the text template and
generate the output file. It instaciates text template object from the template
file and substitute it with the &lt;code&gt;Metadata&lt;/code&gt; object properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Metadata struct {
	PackageName   string
	Object        string
	MarshalObject string
	Type          string
}

type Generator struct {
	Format Format
}

func (g *Generator) Generate(writer io.Writer, metadata Metadata) error {
	tmpl, err := g.template()
	if err != nil {
		return nil
	}

	return tmpl.Execute(writer, metadata)
}

func (g *Generator) template() (*template.Template, error) {
	if g.Format != JSON {
		return nil, errors.New(&amp;quot;Unsupported format&amp;quot;)
	}

	resource, err := Asset(&amp;quot;templates/writeto_json.tmpl&amp;quot;)
	if err != nil {
		return nil, err
	}

	tmpl := template.New(&amp;quot;template&amp;quot;)
	return tmpl.Parse(string(resource))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can read more about text templates in &lt;a href=&#34;https://golang.org/pkg/text/template/&#34;&gt;the official golang
documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;wordsmith&lt;/code&gt; can be used from command line prompt or by annotating &lt;code&gt;Point&lt;/code&gt;
struct with the following comment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate wordsmith -type=Point -format=json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following command identifies the &lt;code&gt;go:generate comment&lt;/code&gt; and executes
declared &lt;code&gt;wordsmith&lt;/code&gt; submcommand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// it scans all
$ go generate ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use the download the full source code from &lt;a href=&#34;http://github.com/svett/wordsmith&#34;&gt;github&lt;/a&gt;
or install it immediatelly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/svett/wordsmith
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h4&gt;

&lt;p&gt;I am looking forward to see more tools in the Go ecosystem. Hopefully this
blog post will encourage more go developers to build such a tools that will boost
our productivity.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Query data with Golang and LINQ</title>
      <link>http://blog.ralch.com/tutorial/golang-query-data-with-linq/</link>
      <pubDate>Sun, 25 Oct 2015 07:35:49 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-query-data-with-linq/</guid>
      <description>

&lt;p&gt;Query langauges provide a set of features to querying, projecting and retrieving
data (usually relational data). But how to introduces these standard,
easily-learned patterns for querying data?&lt;/p&gt;

&lt;p&gt;In this article we will explore &lt;a href=&#34;http://ahmetalpbalkan.github.io/go-linq/&#34;&gt;Go LINQ&lt;/a&gt;
packages that bridges the gap between the world of objects and the world of data.&lt;/p&gt;

&lt;h3 id=&#34;linq&#34;&gt;LINQ&lt;/h3&gt;

&lt;p&gt;For first time is introduced by &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/bb397926.aspx&#34;&gt;Microsoft in their programming language C#&lt;/a&gt;.
Its purpose is to bridge the gap between query languages such as SQL and
programming languages.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Go LINQ&lt;/code&gt; is a query package for Go. Essentially it has ability to apply
queries to slices and collections using SQL-like methods.&lt;/p&gt;

&lt;h4 id=&#34;installation&#34;&gt;Installation&lt;/h4&gt;

&lt;p&gt;As any other &lt;code&gt;go package&lt;/code&gt; we should execute &lt;code&gt;go get&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get ahmetalpbalkan.github.io/go-linq 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;The package consists two query structs that have a set of functions for querying,
projection, grouping, filtering, sorting, aggregation and many more which will
explore in detail. Queries are processed synchronously and asynchronously as well. It
does not evaluate the data lazily. No deferred execution due to lack of enumeration
abstraction. The package works only with slices.&lt;/p&gt;

&lt;p&gt;Lets work with a slice of &lt;code&gt;Company&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Company struct {
	Name    string
	Country string
	City    string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;companies := []company.Company{
	company.Company{Name: &amp;quot;Microsoft&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Redmond&amp;quot;},
	company.Company{Name: &amp;quot;Google&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Palo Alto&amp;quot;},
	company.Company{Name: &amp;quot;Facebook&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Palo Alto&amp;quot;},
	company.Company{Name: &amp;quot;Uber&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;San Francisco&amp;quot;},
	company.Company{Name: &amp;quot;Tweeter&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;San Francisco&amp;quot;},
	company.Company{Name: &amp;quot;SoundCloud&amp;quot;, Country: &amp;quot;Germany&amp;quot;, City: &amp;quot;Berlin&amp;quot;},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The package itself uses &lt;code&gt;reflection&lt;/code&gt; to work any slice or collection of data. It
declares &lt;code&gt;linq.T&lt;/code&gt; interface that used by most of the package functions. In order to work
with a concrete type, it must be casted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var value linq.T
obj := value.(yourType)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;examples&#34;&gt;Examples&lt;/h5&gt;

&lt;p&gt;The example are pretty similar to my previous blog post where I am using [Gen]().
The difference between both libraries is that &lt;code&gt;Gen&lt;/code&gt; relies on code generation
while &lt;code&gt;LINQ&lt;/code&gt; works by using reflection. I haven&amp;rsquo;t done any performance comparisions
to evaluate how slow LINQ is.&lt;/p&gt;

&lt;p&gt;Most of the clojure functions receive &lt;code&gt;linq.T&lt;/code&gt; object as arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// selects all companies located at USA
allUSCompanies := From(companies).Where(func(c T) (bool, error) {
	return c.(company.Company).Country == &amp;quot;USA&amp;quot;, nil
})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// distincts the companies by their country of origin
uniqueCompanies := From(companies).DistinctBy(func(compA T, compB T) (bool, error) {
	return compA.(company.Company).Country == compB.(company.Company).Country, nil
})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// sorts the companies by their name
sortedCompanies := From(companies).OrderBy(func(compA T, compB T) bool {
	return strings.Compare(compA.(company.Company).Name, compB.(company.Company).Name) == -1
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Grouping a slice is processed by &lt;code&gt;GroupBy&lt;/code&gt; function which accepts as argument
two selector functions. The first clojure selects the group key, while the second
returns the object for that key. The result is again a &lt;code&gt;map[T]T&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;groupedCompanies, err := From(companies).GroupBy(func(comp T) T {
	return comp.(company.Company).Country
}, func(c T) T {
	return c
})

if err != nil {
	panic(err)
}

fmt.Println(&amp;quot;US Companies: &amp;quot;, groupedCompanies[&amp;quot;USA&amp;quot;])
fmt.Println(&amp;quot;German Companies: &amp;quot;, groupedCompanies[&amp;quot;Germany&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// projects a slice of companies into a slice of company names
companyNames := From(companies).Select(func(comp T) (T, error) {
	return comp.(company.Company).Name, nil
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;advanced-samples&#34;&gt;Advanced Samples&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;LINQ&lt;/code&gt; package provides some advanced features that are very first citizen
in the query langauges.&lt;/p&gt;

&lt;p&gt;You can intersect two slices by using the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;intersectedCompanies := From(companies).Intersect([]company.Company{
	company.Company{Name: &amp;quot;Microsoft&amp;quot;,
		Country: &amp;quot;USA&amp;quot;,
		City:    &amp;quot;Redmond&amp;quot;},
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to combine two slice into one, you should use the &lt;code&gt;Union&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;unionCompanies := From(companies).Union([]company.Company{
	company.Company{Name: &amp;quot;Skyp&amp;quot;,
		Country: &amp;quot;Latvia&amp;quot;,
		City:    &amp;quot;Talin&amp;quot;},
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets check whether the slice has at least one company that is
in Germany. For that purpose we can use &lt;code&gt;AnyOf&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hasGermanCompany, err := From(companies).AnyWith(func(comp T) (bool, error) {
	return strings.Compare(comp.(company.Company).Country, &amp;quot;Germany&amp;quot;) == 0, nil
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to get all companies that are different than Microsoft, you should
consider using &lt;code&gt;Except&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;openSourceCompanies := From(companies).Except([]company.Company{
	company.Company{Name: &amp;quot;Microsoft&amp;quot;,
		Country: &amp;quot;USA&amp;quot;,
		City:    &amp;quot;Redmond&amp;quot;},
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The package provides us with a &lt;code&gt;join&lt;/code&gt; function that correlates the elements of
collections based on their equality. The first two clojure functions extract the
key for every item in each slice. The third functions extracts the result that
we want.&lt;/p&gt;

&lt;p&gt;In the example below the inner join is between &lt;code&gt;companies&lt;/code&gt; and &lt;code&gt;countries&lt;/code&gt; slice
based on &lt;code&gt;company.Counutry&lt;/code&gt; and &lt;code&gt;country.Name&lt;/code&gt; properties. Objects that have the
same property value are correlated.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;countries := []company.Country{
	company.Country{Name: &amp;quot;USA&amp;quot;,
		Wikipedia: &amp;quot;https://en.wikipedia.org/wiki/United_States&amp;quot;},
	company.Country{Name: &amp;quot;Germany&amp;quot;,
		Wikipedia: &amp;quot;https://en.wikipedia.org/wiki/Germany&amp;quot;},
}

// The join function produces a slice of struct that has two properties
// Company name and Countr Info
companiesWithCountryInfo := From(companies).Join(countries, func(comp T) T {
	return comp.(company.Company).Country
}, func(cntry T) T {
	return cntry.(company.Country).Name
}, func(outer, inner T) T {
	var result struct {
		Company     string
		CountryInfo string
	}

	result.Company = outer.(company.Company).Name
	result.CountryInfo = inner.(company.Country).Wikipedia
	return result
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code snippet above produces a slice of objects that have &lt;code&gt;Company&lt;/code&gt; and &lt;code&gt;CountryInfo&lt;/code&gt;
properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{[{Microsoft https://en.wikipedia.org/wiki/United_States} 
{Google https://en.wikipedia.org/wiki/United_States} 
{Facebook https://en.wikipedia.org/wiki/United_States} 
{Uber https://en.wikipedia.org/wiki/United_States} 
{Tweeter https://en.wikipedia.org/wiki/United_States} 
{SoundCloud https://en.wikipedia.org/wiki/Germany}] &amp;lt;nil&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to get top 3 companies in the slice you can use &lt;code&gt;Take&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;top3comapnies := From(companies).Take(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to get all companies except the first 3 you can use &lt;code&gt;Skip&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;restOfComapnies := From(companies).Skip(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These functions are very handy in implementing paging:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pageNumber := 1
pageItemCount := 20

pagedCompanies := From(companies).
	Skip(pageNumber * pageItemCount).
	Take(pageItemCount)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can read more about the rest of features in the &lt;a href=&#34;https://godoc.org/github.com/ahmetalpbalkan/go-linq&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;verdict&#34;&gt;Verdict&lt;/h4&gt;

&lt;p&gt;LINQ package is not very &lt;code&gt;Go&lt;/code&gt; idiomatic due to its reflection. However, it provides
us with great set of features which does not require any code generation and can be
use out of the box.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generics in Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-code-generation-and-generics/</link>
      <pubDate>Sun, 18 Oct 2015 05:00:00 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-code-generation-and-generics/</guid>
      <description>

&lt;p&gt;In the article we will take the advantage of [generics] even that they are not
first citizen in &lt;code&gt;Go&lt;/code&gt;. We will explore &lt;a href=&#34;http://clipperhouse.github.io/gen&#34;&gt;gen&lt;/a&gt; and
&lt;a href=&#34;https://github.com/cheekybits/genny&#34;&gt;genny&lt;/a&gt; command line tools.&lt;/p&gt;

&lt;h3 id=&#34;gen&#34;&gt;Gen&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Gen&lt;/code&gt; is a code generation tool that brings some generic query functions. It uses
annotations to add this functionality to any structure. The generated code is
part of your package and does not have any external dependencies. This approach
avoids any reflection and produces an efficient concrete implementation for any
annotated type.&lt;/p&gt;

&lt;p&gt;By default the package generates various query functions. They can be used to
project, filter, sort and group slices of the annotated types.&lt;/p&gt;

&lt;h4 id=&#34;installation&#34;&gt;Installation&lt;/h4&gt;

&lt;p&gt;We should use &lt;code&gt;go get&lt;/code&gt; command to install &lt;code&gt;gen&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get clipperhouse.github.io/gen 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;As any other &lt;code&gt;Go&lt;/code&gt; generation tool, &lt;code&gt;Gen&lt;/code&gt; requires a specific annoation comment
declared before the desired type declaration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +gen [*] tag:&amp;quot;Value, Value[T,T]&amp;quot; anothertag
type AnnotatedType
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It begins with the &lt;code&gt;+gen&lt;/code&gt; directive. Optionally it is followed by a &lt;code&gt;[*]&lt;/code&gt;,
indicating that the generated type should be a pointer. Tags and values are
interpreted by the available type writers. They are responsible for the actual
code generation. We will learn more about them in the next section. For now we
will use the default slice type writer.&lt;/p&gt;

&lt;p&gt;Lets use it to generate functions for filtering, distincting, sorting and projecting
a &lt;code&gt;Company&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: company.go
package company

// +gen slice:&amp;quot;Where,GroupBy[string],DistinctBy,SortBy,Select[string]&amp;quot;
type Company struct {
	Name    string
	Country string
	City    string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After declaring the type annoation, we should execute &lt;code&gt;gen&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It produces &lt;code&gt;comapany_slice.go&lt;/code&gt; file that contains the concrete implementation
for any listed function in the comment.&lt;/p&gt;

&lt;p&gt;Lets use the generated functions with the following slice:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;companies := company.CompanySlice{
	company.Company{Name: &amp;quot;Microsoft&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Redmond&amp;quot;},
	company.Company{Name: &amp;quot;Google&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Palo Alto&amp;quot;},
	company.Company{Name: &amp;quot;Facebook&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;Palo Alto&amp;quot;},
	company.Company{Name: &amp;quot;Uber&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;San Francisco&amp;quot;},
	company.Company{Name: &amp;quot;Tweeter&amp;quot;, Country: &amp;quot;USA&amp;quot;, City: &amp;quot;San Francisco&amp;quot;},
	company.Company{Name: &amp;quot;SoundCloud&amp;quot;, Country: &amp;quot;Germany&amp;quot;, City: &amp;quot;Berlin&amp;quot;},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets get all companies that are based on USA. For that you should use the &lt;code&gt;Where&lt;/code&gt;
function, which receives predicate function as an argument.&lt;/p&gt;

&lt;p&gt;The clojure function receives a company object as argument and returns
boolean value. It is executed for every item in the slice. It should retun
&lt;code&gt;true&lt;/code&gt; for all objects that meets our criteria:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;allUSCompanies := companies.Where(func(comp company.Company) bool {
	return comp.Country == &amp;quot;USA&amp;quot;
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we distinct all companies by their country of origin, we should use the
&lt;code&gt;DistinctBy&lt;/code&gt; function that uses a function that checks two company objects
for equaty:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;uniqueCompanies := companies.DistinctBy(func(compA company.Company, compB company.Company) bool {
	return compA.Country == compB.Country
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to sort the companies by their name, we should use &lt;code&gt;SortBy&lt;/code&gt; function
that receives as an argument a function that determines whether its first argument
is less that second one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// In our case we can use strings.Compare to compare to strings. It returns -1
// the first string is less than the second.
sortedCompanies := companies.SortBy(func(compA company.Company, compB company.Company) bool {
	return strings.Compare(compA.Name, compB.Name) == -1
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to group the companies by their country of residence, we can use
&lt;code&gt;GroupByString&lt;/code&gt; function that returns a &lt;code&gt;map[string]company.CompanySlice&lt;/code&gt; object.
The key of every entry is determined by its clojure function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;groupedCompanies := companies.GroupByString(func(comp company.Company) string {
	return comp.Country
})

fmt.Println(&amp;quot;US Companies: &amp;quot;, groupedCompanies[&amp;quot;USA&amp;quot;])
fmt.Println(&amp;quot;German Companies: &amp;quot;, groupedCompanies[&amp;quot;Germany&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The company slice can be projected as a string by using generated &lt;code&gt;Select&lt;/code&gt;
function. The following code snippet projects the list of companies as a list
of company names:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;companyNames := companies.SelectString(func(comp company.Company) string {
	return comp.Name
})

fmt.Println(companyNames)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// This slice of strings is produced by the code snippet
[Microsoft Google Facebook Uber Tweeter SoundCloud]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A great &lt;code&gt;Gen&lt;/code&gt; feature is that most of the functions can be chained. Lets select
all companies based in USA then order them by their name and format their name
in the following format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%COMPANY_NAME% is based in %CITY%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can simply chain &lt;code&gt;Where&lt;/code&gt;, &lt;code&gt;SortBy&lt;/code&gt; and &lt;code&gt;SelectString&lt;/code&gt; functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;result := companies.Where(func(comp company.Company) bool {
	return comp.Country == &amp;quot;USA&amp;quot;
}).SortBy(func(compA company.Company, compB company.Company) bool {
	return strings.Compare(compA.Name, compB.Name) == -1
}).SelectString(func(comp company.Company) string {
	return fmt.Sprintf(&amp;quot;%s&#39;s is based in %s&amp;quot;, comp.Name, comp.City)
})

for _, text := range result {
	fmt.Println(text)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can read more about another auxiliary function in the &lt;a href=&#34;http://clipperhouse.github.io/gen/slice/&#34;&gt;official documentation&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;implementing-a-type-writer&#34;&gt;Implementing a type writer&lt;/h4&gt;

&lt;p&gt;The type writers are responsible for interpreting the annotated tags and
generating go code. They are implementing the following interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Interface interface {
	Name() string
	Imports(t Type) []ImportSpec
	Write(w io.Writer, t Type) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Name&lt;/code&gt; returns the writer&amp;rsquo;s name&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Imports&lt;/code&gt; function returns a slice of packages that are required and written
as imports in the generated file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Write&lt;/code&gt; function writes the actual generated code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets implement a writer that generates the &lt;code&gt;Stack&lt;/code&gt; data structure. &lt;code&gt;Gen&lt;/code&gt; uses
&lt;a href=&#34;https://golang.org/pkg/text/template/&#34;&gt;text/template&lt;/a&gt; as a templating format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A structure that represents a stack data structure
// for {{.Name}} type
//
// Example:
// stack := &amp;amp;stack.Stack{}
// stack.Push(new(TValue))
// value, err := stack.Pop()
type {{.Name}}Stack struct {
	data []{{.Pointer}}{{.Name}}
}

// Adds an element on top of the stack
func (s *{{.Name}}Stack) Push(value {{.Pointer}}{{.Name}}) {
	s.data = append(s.data, value)
}

// Removes an element from top of the stack.
// If the stack is empty, it returns an error.
func (s *{{.Name}}Stack) Pop() ({{.Pointer}}{{.Name}}, error) {
	length := len(s.data)
	if length == 0 {
		return nil, errors.New(&amp;quot;Stack is empty&amp;quot;)
	}

	value := s.data[length-1]
	s.data = s.data[:length-1]
	return value, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The template declared by &lt;code&gt;typewriter.Template&lt;/code&gt; instance. The &lt;code&gt;templateContent&lt;/code&gt;
variable contains the actual &lt;code&gt;text/template&lt;/code&gt; string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: templates.go
package stack

import &amp;quot;github.com/clipperhouse/typewriter&amp;quot;

var templates = typewriter.TemplateSlice{
	stackTmpl,
}

var stackTmpl = &amp;amp;typewriter.Template{
	Name: &amp;quot;Stack&amp;quot;,
	Text: templateContent,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following structure implements a type writer responsible for code generation
of declared template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: stack.go
package stack

import (
	&amp;quot;io&amp;quot;

	&amp;quot;github.com/clipperhouse/typewriter&amp;quot;
)

func init() {
	if err := typewriter.Register(NewWriter()); err != nil {
		panic(err)
	}
}

type writer struct{}

// Creates a new stack type writer
func NewWriter() typewriter.Interface {
	return &amp;amp;writer{}
}

func (tw *writer) Name() string {
	return &amp;quot;stack&amp;quot;
}

func (tw *writer) Imports(t typewriter.Type) (result []typewriter.ImportSpec) {
	return
}

func (tw *writer) Write(w io.Writer, t typewriter.Type) error {
  // retrieve that for this type writer a tag is declared in the annoation
	// if it&#39;s not found the writer won&#39;t be generate anything
	tag, found := t.FindTag(tw)

	if !found {
		return nil
	}

  // Write a header commend in the generated file
	header := &amp;quot;// DO NOT MODIFY. Auto-generated code.&amp;quot;
	if _, err := w.Write([]byte(header)); err != nil {
		return err
	}
	
	// A template for the exact tag is retrieved
	tmpl, err := templates.ByTag(t, tag)
	if err != nil {
		return err
	}

  // Write out the template substitution to the writer
	if err := tmpl.Execute(w, t); err != nil {
		return err
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In ored to use the template we should declare annotation. Lets annotate
&lt;code&gt;company.Company&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +gen * stack
type Company struct {
	Name    string
	Country string
	City    string
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After executing &lt;code&gt;$ gen&lt;/code&gt; command a &lt;code&gt;company_stack.go&lt;/code&gt; file is placed in the package
directory. It contains an actual implementation of &lt;code&gt;CompanyStack&lt;/code&gt; structure,
which can be used in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stack := &amp;amp;StudentStack{}
stack.Push(&amp;amp;Student{FirstName: &amp;quot;John&amp;quot;, LastName: &amp;quot;Smith&amp;quot;})
student, err := stack.Pop()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A complete implementation of the custom type writer can be pulled from
&lt;a href=&#34;https://github.com/svett/gen&#34;&gt;this repository&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;genny&#34;&gt;Genny&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Genny&lt;/code&gt; is a code-generation tool that replaces usage of generics. It allows
to transform a Go source code into specific implementation by replacing its
generic types.&lt;/p&gt;

&lt;h4 id=&#34;installation-1&#34;&gt;Installation&lt;/h4&gt;

&lt;p&gt;Install by executing &lt;code&gt;go get&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/cheekybits/genny
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-1&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;The tool uses a similar approach as &lt;code&gt;gotemplate&lt;/code&gt;. A special comment should be
provided in order to be recognised by &lt;code&gt;go generate&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen &amp;quot;KeyType=string,int ValueType=string,int&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Parameters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-in&lt;/code&gt; specifies the input file (template)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-out&lt;/code&gt; specifies the output file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$GOFILE&lt;/code&gt; refers to the current file&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KeyType&lt;/code&gt; and &lt;code&gt;ValueType&lt;/code&gt; are the parameter names in the specified template&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As the other tools, we should just call &lt;code&gt;go generate&lt;/code&gt; to produce a file that is
result of substition between the template and provided parameters.&lt;/p&gt;

&lt;h3 id=&#34;declaring-generics&#34;&gt;Declaring generics&lt;/h3&gt;

&lt;p&gt;The template can contains as many as we require parameters. They should be defined
using the special genny type &lt;code&gt;generic.Type&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type KeyType generic.Type
type ValueType generic.Type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets port the &lt;code&gt;Stack&lt;/code&gt; data struct in &lt;code&gt;genny&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate genny -in=$GOFILE -out=gen-$GOFILE gen &amp;quot;ValueType=*Student&amp;quot;
type ValueType generic.Type

type Stack struct {
	data []ValueType
}

func (s *Stack) Push(value TValueType) {
	s.data = append(s.data, value)
}

func (s *Stack) Pop() (TValueType, error) {
	length := len(s.data)
	if length == 0 {
		return nil, errors.New(&amp;quot;Stack is empty&amp;quot;)
	}

	value := s.data[length-1]
	s.data = s.data[:length-1]
	return value, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Significant difference from &lt;code&gt;gotemplate&lt;/code&gt; is that in &lt;code&gt;genny&lt;/code&gt; the special &lt;code&gt;go:generate&lt;/code&gt;
comment should be placed in the actual template. This can be avoid by executing
&lt;code&gt;genny&lt;/code&gt; from the command line shell:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat ./stack.go | genny gen &amp;quot;ValueType=*Student&amp;quot; &amp;gt; student_stack.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Do you still complain that &lt;code&gt;Go&lt;/code&gt; does not support generics?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gen&lt;/code&gt; and &lt;code&gt;genny&lt;/code&gt; are great tools for automating a common development tasks. Because of their
template nature, we can focus on what should be generated instead of how to generate it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Reusing source code with Go templates</title>
      <link>http://blog.ralch.com/tutorial/golang-code-generation-with-gotemplates/</link>
      <pubDate>Sun, 11 Oct 2015 20:42:57 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-code-generation-with-gotemplates/</guid>
      <description>

&lt;p&gt;In one of my previous blog posts, we discovered &lt;code&gt;go generate&lt;/code&gt; command line
tool. Lets take the next step and evaluate its advanced benefits to generate a source code
by using our own templates. We will explore &lt;a href=&#34;https://github.com/ncw/gotemplate&#34;&gt;gotemplate&lt;/a&gt;
command line tool.&lt;/p&gt;

&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;

&lt;p&gt;This command line tool manages package based &lt;code&gt;Go&lt;/code&gt; templates using &lt;code&gt;go generate&lt;/code&gt;.
By default it provides a set of templates that can be used out of the box:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/ncw/gotemplate/set&#34;&gt;set&lt;/a&gt; - a template that generates a &lt;code&gt;set&lt;/code&gt; struct for a type&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/ncw/gotemplate/list&#34;&gt;list&lt;/a&gt; - a template that generates a &lt;code&gt;list&lt;/code&gt; struct for a type&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/ncw/gotemplate/sort&#34;&gt;sort&lt;/a&gt; - a template that provides a sort primitivies for a type&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://godoc.org/github.com/ncw/gotemplate/heap&#34;&gt;heap&lt;/a&gt; - a template that provides &lt;code&gt;heap&lt;/code&gt; operations for a type&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;It is simple to install by using &lt;code&gt;go get&lt;/code&gt; command.
Note that the command installs the predefined templates as well.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/ncw/gotemplate/...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;To instaciate a particular template, you must use it using a special comment in your code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate gotemplate &amp;quot;github.com/ncw/gotemplate/list&amp;quot; StudentList(Student)
type Student struct {
	FirstName string
	LastName  string
	BirthDate time.Time
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Afte executing &lt;code&gt;go generate&lt;/code&gt; command, a file &lt;a href=&#34;https://gist.github.com/86acbeea21c02af69e70&#34;&gt;gotemplate_StudentList.go&lt;/a&gt;
is generated. It contains the &lt;code&gt;StudentList&lt;/code&gt; type that defines a list struct
that works with &lt;code&gt;Student&lt;/code&gt; type. It has the following methods and functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+StudentList : struct
  [methods]
  +Back() : *StudentListElement
  +Front(): *StudentListElement
  +Init() : *StudentList
  +InsertAfter(v Student, mark *StudentListElement) : *StudentListElement
  +InsertBefore(v Student, mark *StudentListElement) : *StudentListElement
  +Len() : int
  +MoveToBack(e *StudentListElement)
  +MoveToFront(e *StudentListElement)
  +PushBack(v Student) : *StudentListElement
  +PushBackList(other *StudentList)
  +PushFront(v Student) : *StudentListElement
  +PushFrontList(other *StudentList)
  +Remove(e *StudentListElement) : Student
  [functions]
  +NewStudentList() : *StudentList
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use it in the following manner:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;spike/education&amp;quot;
)

func main() {
	student := education.Student{
		FirstName: &amp;quot;John&amp;quot;,
		LastName:  &amp;quot;Smith&amp;quot;,
	}

	list := education.NewStudentList()
	list.PushFront(student)

	fmt.Println(list.Front().Value.FirstName)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Using an initial capital when you name your template instantiation will make
any external functions and types public. If you want to generate them as private
you must use lower case like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate gotemplate &amp;quot;github.com/ncw/gotemplate/set&amp;quot; stringSet(string)
//go:generate gotemplate &amp;quot;github.com/ncw/gotemplate/set&amp;quot; floatSet(float64)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then code generation produces &lt;code&gt;gotemplate_stringSet.go&lt;/code&gt; and &lt;code&gt;gotemplate_floateSet.go&lt;/code&gt; files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go generate
substituting &amp;quot;github.com/ncw/gotemplate/set&amp;quot; with stringSet(string) into package main
Written &#39;gotemplate_stringSet.go&#39;
substituting &amp;quot;github.com/ncw/gotemplate/set&amp;quot; with floatSet(float64) into package main
Written &#39;gotemplate_floatSet.go&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;creating-a-custom-templates&#34;&gt;Creating a custom templates&lt;/h3&gt;

&lt;p&gt;Templates must be valid go packages. They should compile and have tests and be usable as-is.&lt;/p&gt;

&lt;p&gt;To make the package a valid template it should have one or more declarations and
a special comment that declares the its template name and parameters.&lt;/p&gt;

&lt;p&gt;The line below indicates that the base name for the template is &lt;code&gt;TemplateType&lt;/code&gt;
and it has one type parameter &lt;code&gt;TParameter&lt;/code&gt;. Supported parameterized declarations
are type, const, var and func.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// template type TemplateType(TParameter)
type TParameter int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets implement a template for &lt;a href=&#34;http://bit.ly/1Pwvd5W&#34;&gt;Stack data structure&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package stack

import &amp;quot;errors&amp;quot;

// template type Stack(TValue)
type TValue *int

type Stack struct {
	data []TValue
}

func (s *Stack) Push(value TValue) {
	s.data = append(s.data, value)
}

func (s *Stack) Pop() (TValue, error) {
	length := len(s.data)
	if length == 0 {
		return nil, errors.New(&amp;quot;Stack is empty&amp;quot;)
	}

	value := s.data[length-1]
	s.data = s.data[:length-1]
	return value, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets declare it for &lt;code&gt;Student&lt;/code&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate gotemplate &amp;quot;github.com/svett/gotemplate/stack&amp;quot; StudentStack(*Student)
type Student struct {
	FirstName string
	LastName  string
	BirthDate time.Time
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can instatiate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/svett/gotemplate/stack
$ go generate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the template is instantiated, a new file &lt;code&gt;gotemplate_StudentStack.go&lt;/code&gt; is create.
It is a result of substition of actual template with &lt;code&gt;StudentStack(*Student)&lt;/code&gt; declaration.
All &lt;code&gt;TValue&lt;/code&gt; occurances are replaced with &lt;code&gt;Student&lt;/code&gt;. The &lt;code&gt;Stack&lt;/code&gt; struct is changed to &lt;code&gt;StudentStack&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The template can be downloaded from &lt;a href=&#34;https://github.com/svett/gotemplate/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Gotemplate&lt;/code&gt; is great tool for automatic a common development tasks. Because of its
extensibility, we can focus on what should be generated instead of how to generate it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang code generation</title>
      <link>http://blog.ralch.com/tutorial/golang-code-generation/</link>
      <pubDate>Sun, 04 Oct 2015 08:49:59 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-code-generation/</guid>
      <description>

&lt;p&gt;Programs that produce source code are important elements in software engineering.
Since Go 1.4, the language ecosystem includes a command line tool that makes
it easier to run such tools.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s called &lt;code&gt;go generate&lt;/code&gt;. It scans for special comments in Go
source code that identify general commands to run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate &amp;lt;subcommand&amp;gt; &amp;lt;arguments&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Go generate&lt;/code&gt; is not part of go build. It does not do dependency analysis and
must be run explicitly before running go build. It is intended to be used by
the author of the Go package, not its consumers.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;go generate&lt;/code&gt; command is easy to use. Usually it is executed in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// it scans all 
$ go generate ./...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After identifying all &lt;code&gt;go:generate&lt;/code&gt; comments it will execute the specified commands.&lt;/p&gt;

&lt;p&gt;In this article, we will explore a various tools that produce source code for us.&lt;/p&gt;

&lt;h3 id=&#34;json-enums&#34;&gt;JSON Enums&lt;/h3&gt;

&lt;p&gt;Have you ever had an enum that you want to serialize in JSON as a string instead of integer?
Are you bored of developing a &lt;code&gt;switch&lt;/code&gt; cases that handle that? It is time to automate this
task by using &lt;code&gt;jsonenums&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/campoy/jsonenums&#34;&gt;jsonenums&lt;/a&gt; is a code generation tool to automate the creation of methods
that satisfy the &lt;a href=&#34;https://golang.org/pkg/encoding/json/#Marshaler&#34;&gt;json.Marshaler&lt;/a&gt; and &lt;a href=&#34;https://golang.org/pkg/encoding/json/#Unmarshaler&#34;&gt;json.Unmarshaler&lt;/a&gt; interfaces.&lt;/p&gt;

&lt;h4 id=&#34;installing&#34;&gt;Installing&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/campoy/jsonenums
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;Lets have this enum definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate jsonenums -type=Status
type Status int

const (
	Pending Status = iota
	Sent
	Received
	Rejected
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running &lt;code&gt;go generate&lt;/code&gt; produces &lt;code&gt;status_jsonenums.go&lt;/code&gt; file in the same package.
It contains the actual implementation for JSON serialization of &lt;code&gt;Status&lt;/code&gt; enum.
Then we can serialize an enum variable in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;status := Received
data, err := status.MarshalJSON()
if err != nil {
	panic(err)
}

statusCopy := new(Status)
err = statusCopy.UnmarshalJSON(data)
if err != nil {
	panic(err)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can download the whole code snippet from &lt;a href=&#34;https://gist.github.com/svett/0053bab033a581f7675a&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;fast-json&#34;&gt;Fast JSON&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/pquerna/ffjson&#34;&gt;ffjson&lt;/a&gt;  generates &lt;code&gt;MarshalJSON&lt;/code&gt; and &lt;code&gt;UnmarshalJSON&lt;/code&gt; functions for struct types.
These functions reduce the reliance unpon runtime reflection to do serialization.
According to the author notes, it is generally 2 to 3 times faster than
&lt;code&gt;encoding/json&lt;/code&gt; package.&lt;/p&gt;

&lt;h4 id=&#34;installing-1&#34;&gt;Installing&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/pquerna/ffjson 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-1&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;The generated code is baed upon existing struct types. Lets have &lt;code&gt;education.go&lt;/code&gt; file.
&lt;code&gt;ffjson&lt;/code&gt; will generate a new file &lt;code&gt;education_ffjson.go&lt;/code&gt; that contains serialization
functions for all structs found in &lt;code&gt;education.go&lt;/code&gt;. In order to do that we should
add the following &lt;code&gt;go:generate&lt;/code&gt; comment in &lt;code&gt;education.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate ffjson $GOFILE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a sample version of &lt;code&gt;education.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate ffjson $GOFILE
package education

type Student struct {
	FirstName string
	LastName  string
}

type University struct {
	Name     string
	Students []Student
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Executing &lt;code&gt;go generate ./...&lt;/code&gt; produces &lt;code&gt;education_ffjson.go&lt;/code&gt; that contains all
json serialization code for &lt;code&gt;Student&lt;/code&gt; and &lt;code&gt;University&lt;/code&gt; structs. Then we can use
&lt;code&gt;ffjson&lt;/code&gt; package to marshal these types and unmasrshal their &lt;code&gt;JSON&lt;/code&gt; representation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
	&amp;quot;spike/education&amp;quot;

	&amp;quot;github.com/pquerna/ffjson/ffjson&amp;quot;
)

func main() {
	student := education.Student{
		FirstName: &amp;quot;John&amp;quot;,
		LastName:  &amp;quot;Smith&amp;quot;,
	}

	university := education.University{
		Name:     &amp;quot;MIT&amp;quot;,
		Students: []education.Student{student},
	}

	json, err := ffjson.Marshal(&amp;amp;university)
	if err != nil {
		panic(err)
	}

	var universityCopy education.University
	err = ffjson.Unmarshal(json, &amp;amp;universityCopy)
	if err != nil {
		panic(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sample code can be downloaded from &lt;a href=&#34;https://gist.github.com/svett/053b3bd64612a8677389&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;stringer&#34;&gt;Stringer&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/cmd/stringer&#34;&gt;Stringer&lt;/a&gt; is a similar to &lt;code&gt;jsonenums&lt;/code&gt;.
But it generates a &lt;a href=&#34;https://golang.org/pkg/fmt/#Stringer&#34;&gt;fmt.Stringer interface&lt;/a&gt; implementation for enums.&lt;/p&gt;

&lt;h4 id=&#34;installing-2&#34;&gt;Installing&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get golang.org/x/tools/cmd/stringer
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-2&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;Lets auto-generate &lt;code&gt;fmt.Stringer&lt;/code&gt; interface for &lt;code&gt;MessageStatus&lt;/code&gt; enum:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate stringer -type=MessageStatus
type MessageStatus int

const (
	Sent MessageStatus = iota
	Received
	Rejected
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Go generate&lt;/code&gt; produces &lt;code&gt;messagestatus_string.go&lt;/code&gt; file which contains the actual
implementation. Then the following snippet prints out &lt;code&gt;Message is Sent&lt;/code&gt; instead
of &lt;code&gt;Message is 0&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
	status := Sent
	fmt.Printf(&amp;quot;Message is %s&amp;quot;, status)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Full source code can be download from &lt;a href=&#34;https://gist.github.com/svett/b5194dfb109626579e77&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Go generate&lt;/code&gt; is great opportunity to automate many implementation tasks
that are very common in our day to day job. I am really pleased to see more and
more tools coming up.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang: Working with Gzip and Tar</title>
      <link>http://blog.ralch.com/tutorial/golang-working-with-tar-and-gzip/</link>
      <pubDate>Sun, 27 Sep 2015 14:58:56 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-working-with-tar-and-gzip/</guid>
      <description>

&lt;h3 id=&#34;gzip&#34;&gt;Gzip&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Gzip&#34;&gt;Gzip&lt;/a&gt; is another file compression format
that was created to replace the &lt;code&gt;compress&lt;/code&gt; program used in early &lt;code&gt;unix&lt;/code&gt; system.
It is normally used to compress just single files.  Compressed archives are
created by packaging collections of files into a single tar archive,
and then compressing that archive with gzip. The final &lt;code&gt;.tar.gz&lt;/code&gt; or &lt;code&gt;.tgz&lt;/code&gt; file is a tarball.&lt;/p&gt;

&lt;h4 id=&#34;compressing-a-file&#34;&gt;Compressing a file&lt;/h4&gt;

&lt;p&gt;Compressing operation is very simple to implement. The package exposes &lt;code&gt;gzip.Writer&lt;/code&gt; struct
that compress any content provided via its &lt;code&gt;Write&lt;/code&gt; function. You can specify some metadata
information about the compressed file by setting some properties of &lt;code&gt;gzip.Header&lt;/code&gt;
struct which is embedded into &lt;code&gt;gzip.Writer&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The gzip file stores a header giving metadata about the compressed file.
// That header is exposed as the fields of the Writer and Reader structs.
type Header struct {
	Comment string    // comment
	Extra   []byte    // &amp;quot;extra data&amp;quot;
	ModTime time.Time // modification time
	Name    string    // file name
	OS      byte      // operating system type
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can compress a file by using the following function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func gzipit(source, target string) error {
	reader, err := os.Open(source)
	if err != nil {
		return err
	}

	filename := filepath.Base(source)
	target = filepath.Join(target, fmt.Sprintf(&amp;quot;%s.gz&amp;quot;, filename))
	writer, err := os.Create(target)
	if err != nil {
		return err
	}
	defer writer.Close()

	archiver := gzip.NewWriter(writer)
	archiver.Name = filename
	defer archiver.Close()

	_, err = io.Copy(archiver, reader)
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that &lt;code&gt;target&lt;/code&gt; argument should be a directory.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;decompressing-a-file&#34;&gt;Decompressing a file&lt;/h4&gt;

&lt;p&gt;This operation is simple as its contrapart. But in this case we should use
&lt;code&gt;gzip.Reader&lt;/code&gt; to read the compressed array of bytes. We can read the metadata information
such as compressed file name via &lt;code&gt;gzip.Header&lt;/code&gt; struct (embedded in &lt;code&gt;gzip.Reader&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;If you need to uncompress a gzip package, you should use this sample:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ungzip(source, target string) error {
	reader, err := os.Open(source)
	if err != nil {
		return err
	}
	defer reader.Close()

	archive, err := gzip.NewReader(reader)
	if err != nil {
		return err
	}
	defer archive.Close()

	target = filepath.Join(target, archive.Name)
	writer, err := os.Create(target)
	if err != nil {
		return err
	}
	defer writer.Close()

	_, err = io.Copy(writer, archive)
	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that &lt;code&gt;target&lt;/code&gt; argument should be a directory.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You can download the &lt;code&gt;gzip&lt;/code&gt; example from [here]().&lt;/p&gt;

&lt;h4 id=&#34;usage&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;You can use both functions in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gzipit(&amp;quot;/tmp/document.txt&amp;quot;, &amp;quot;/tmp&amp;quot;)
ungzip(&amp;quot;/tmp/document.txt.gz&amp;quot;, &amp;quot;/tmp&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tar&#34;&gt;Tar&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://bit.ly/1DqSuzH&#34;&gt;Tar&lt;/a&gt; is an archive file for
distribution of hudge fileset. Known as &lt;code&gt;tap archive&lt;/code&gt; it was developed to
write data to sequential &lt;code&gt;io&lt;/code&gt; devices.&lt;/p&gt;

&lt;p&gt;The tar contains multiple paramaeters, such as timestamp, ownership, file
permissions and directories.&lt;/p&gt;

&lt;p&gt;If you want to create a tar package, you should use the following
code snippet walk through the directory hierarchy and write its content. Every
written header encodes metadata file information &lt;code&gt;os.FileInfo&lt;/code&gt;.
Because os.FileInfo&amp;rsquo;s Name method returns only the base name of
the file it describes, it may be necessary to modify the Name field
of the returned header to provide the full path name of the file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func tarit(source, target string) error {
	filename := filepath.Base(source)
	target = filepath.Join(target, fmt.Sprintf(&amp;quot;%s.tar&amp;quot;, filename))
	tarfile, err := os.Create(target)
	if err != nil {
		return err
	}
	defer tarfile.Close()

	tarball := tar.NewWriter(tarfile)
	defer tarball.Close()

	info, err := os.Stat(source)
	if err != nil {
		return nil
	}

	var baseDir string
	if info.IsDir() {
		baseDir = filepath.Base(source)
	}

	return filepath.Walk(source, 
	func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		header, err := tar.FileInfoHeader(info, info.Name())
		if err != nil {
			return err
		}

		if baseDir != &amp;quot;&amp;quot; {
			header.Name = filepath.Join(baseDir, strings.TrimPrefix(path, source))
		}

		if err := tarball.WriteHeader(header); err != nil {
			return err
		}

		if info.IsDir() {
			return nil
		}

		file, err := os.Open(path)
		if err != nil {
			return err
		}
		defer file.Close()
		_, err = io.Copy(tarball, file)
		return err
	})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To unpack a tar you should use &lt;code&gt;tar.Reader&lt;/code&gt; struct to read all headers. Every
header declares the begining of every directory and file in the tarball. By accessing
its &lt;code&gt;FileInfo&lt;/code&gt; property you can recreate the files and the directories:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func untar(tarball, target string) error {
	reader, err := os.Open(tarball)
	if err != nil {
		return err
	}
	defer reader.Close()
	tarReader := tar.NewReader(reader)

	for {
		header, err := tarReader.Next()
		if err == io.EOF {
			break
		} else if err != nil {
			return err
		}

		path := filepath.Join(target, header.Name)
		info := header.FileInfo()
		if info.IsDir() {
			if err = os.MkdirAll(path, info.Mode()); err != nil {
				return err
			}
			continue
		}

		file, err:= os.OpenFile(path, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, info.Mode())
		if err != nil {
			return err
		}
		defer file.Close()
		_, err =io.Copy(file, tarReader)
		if err != nil {
			return err
		}
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that &lt;code&gt;target&lt;/code&gt; argument should be a directoy.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You can download the &lt;code&gt;tar&lt;/code&gt; code snippets from &lt;a href=&#34;https://gist.github.com/svett/76799ba2edca89961be6&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;usage-1&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;You can use call the functions in the following way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tarit(&amp;quot;/tmp/utils, &amp;quot;/tmp&amp;quot;)
untar(&amp;quot;/tmp/utils.tar&amp;quot;, &amp;quot;/tmp&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Golang: Working with ZIP archives</title>
      <link>http://blog.ralch.com/tutorial/golang-working-with-zip/</link>
      <pubDate>Sun, 20 Sep 2015 14:58:56 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-working-with-zip/</guid>
      <description>

&lt;p&gt;Golang has several packages that work with different type of archives.
In this post I will show you how to use &lt;code&gt;archive/zip&lt;/code&gt; package to compress and
uncompress &lt;code&gt;zip&lt;/code&gt; archives.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://bit.ly/1OeinbI&#34;&gt;Zip&lt;/a&gt; is one of the most common
file formats. It supports &lt;code&gt;lossless data compression&lt;/code&gt; of one ore more files and
directories.&lt;/p&gt;

&lt;h3 id=&#34;extracting&#34;&gt;Extracting&lt;/h3&gt;

&lt;p&gt;You can read the content of &lt;code&gt;zip&lt;/code&gt; package by using zip reader. Its &lt;code&gt;File&lt;/code&gt; property
exposes all files and directories of particular zip package. If you want to extract
the package, you should recreate all directories and files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func unzip(archive, target string) error {
	reader, err := zip.OpenReader(archive)
	if err != nil {
		return err
	}

	if err := os.MkdirAll(target, 0755); err != nil {
		return err
	}

	for _, file := range reader.File {
		path := filepath.Join(target, file.Name)
		if file.FileInfo().IsDir() {
			os.MkdirAll(path, file.Mode())
			continue
		}

		fileReader, err := file.Open()
		if err != nil {
			return err
		}
		defer fileReader.Close()

		targetFile, err := os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, file.Mode())
		if err != nil {
			return err
		}
		defer targetFile.Close()

		if _, err := io.Copy(targetFile, fileReader); err != nil {
			return err
		}
	}

	return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;compressing&#34;&gt;Compressing&lt;/h3&gt;

&lt;p&gt;This operation is more complicated than &lt;code&gt;extracing&lt;/code&gt;. You can compress a single file
or an hierarchy of directories. Handling both cases requires to change the file
header name depending on its type. If the copied content is directory, the header name
should be changed to &lt;code&gt;&amp;lt;directory_name&amp;gt;/&lt;/code&gt;. For a regular files, its header name is relative
path &lt;code&gt;&amp;lt;directory_name&amp;gt;/&amp;lt;file_name&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The following function illustrates the algorithm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func zipit(source, target string) error {
	zipfile, err := os.Create(target)
	if err != nil {
		return err
	}
	defer zipfile.Close()

	archive := zip.NewWriter(zipfile)
	defer archive.Close()

	info, err := os.Stat(source)
	if err != nil {
		return nil
	}

	var baseDir string
	if info.IsDir() {
		baseDir = filepath.Base(source)
	}

	filepath.Walk(source, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		header, err := zip.FileInfoHeader(info)
		if err != nil {
			return err
		}

		if baseDir != &amp;quot;&amp;quot; {
			header.Name = filepath.Join(baseDir, strings.TrimPrefix(path, source))
		}

		if info.IsDir() {
			header.Name += &amp;quot;/&amp;quot;
		} else {
			header.Method = zip.Deflate
		}

		writer, err := archive.CreateHeader(header)
		if err != nil {
			return err
		}

		if info.IsDir() {
			return nil
		}

		file, err := os.Open(path)
		if err != nil {
			return err
		}
		defer file.Close()
		_, err = io.Copy(writer, file)
		return err
	})

	return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;usage&#34;&gt;Usage&lt;/h3&gt;

&lt;p&gt;Lets see both functions in action:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zipit(&amp;quot;/tmp/documents&amp;quot;, &amp;quot;/tmp/backup.zip&amp;quot;)
zipit(&amp;quot;/tmp/report.txt&amp;quot;, &amp;quot;/tmp/report-2015.zip&amp;quot;)
unzip(&amp;quot;/tmp/report-2015.zip&amp;quot;, &amp;quot;/tmp/reports/&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can download the samples from &lt;a href=&#34;https://gist.github.com/svett/424e6784facc0ba907ae&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang code inspection tools</title>
      <link>http://blog.ralch.com/tutorial/golang-tools-inspection/</link>
      <pubDate>Sun, 13 Sep 2015 08:55:41 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-tools-inspection/</guid>
      <description>

&lt;p&gt;As a software engineer, you always try to improve the quality of your programs.
We are looking for the best software development practices and TDD techniques.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;Have no fear of perfection - you&#39;ll never reach it.&amp;quot;
 Salvador Dal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this article we will explore different code inspection tools in &lt;code&gt;Go&lt;/code&gt; ecosystem.
We will increase our code quality and engineering skills by running tools
that will do analysis on our code base and report the suspicious parts of it.&lt;/p&gt;

&lt;h2 id=&#34;govet&#34;&gt;Govet&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Vet&lt;/code&gt; does analysis on Go source code and reports suspicious constructs.
It uses heuristics that do not guarantee all reports are genuine problems.
&lt;code&gt;Vet&lt;/code&gt; can find errors not caught by the compilers.&lt;/p&gt;

&lt;p&gt;It can be invoked in three different ways:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// for go package
$ go tool vet package/path/name
// for files
$ go tool vet source/directory/*.go
// for directory
$ go tool vet source/directory
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What should be analysed can be controlled with these flags (extraced from help doc):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-all&lt;/code&gt; check everything; disabled if any explicit check is requested (default true)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-asmdecl&lt;/code&gt; check assembly against Go declarations (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-assign&lt;/code&gt; check for useless assignments (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-atomic&lt;/code&gt; check for common mistaken usages of the sync/atomic package (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-bool&lt;/code&gt; check for mistakes involving boolean operators (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-buildtags&lt;/code&gt; check that +build tags are valid (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-composites&lt;/code&gt; check that composite literals used field-keyed elements (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-compositewhitelist&lt;/code&gt; use composite white list; for testing only (default true)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-copylocks&lt;/code&gt; check that locks are not passed by value (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-methods&lt;/code&gt; check that canonically named methods are canonically defined (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-nilfunc&lt;/code&gt; check for comparisons between functions and nil (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-printf&lt;/code&gt; check printf-like invocations (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-printfuncs&lt;/code&gt; string comma-separated list of print function names to check&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-rangeloops&lt;/code&gt; check that range loop variables are used correctly (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-shadow&lt;/code&gt; check for shadowed variables (experimental; must be set explicitly) (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-shadowstrict&lt;/code&gt; whether to be strict about shadowing; can be noisy&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-shift&lt;/code&gt; check for useless shifts (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-structtags&lt;/code&gt; check that struct field tags have canonical format and apply to exported fields as needed (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-tags&lt;/code&gt; string comma-separated list of build tags to apply when parsing&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-test&lt;/code&gt; for testing only: sets -all and -shadow&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-unreachable&lt;/code&gt; check for unreachable code (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-unsafeptr&lt;/code&gt; check for misuse of unsafe.Pointer (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-unusedfuncs&lt;/code&gt; string comma-separated list of functions whose results must be used (default &amp;ldquo;errors.New,fmt.Errorf,fmt.Sprintf,fmt.Sprint,sort.Reverse&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-unusedresult&lt;/code&gt; check for unused result of calls to functions in -unusedfuncs list and methods in -unusedstringmethods list (default unset)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-unusedstringmethods&lt;/code&gt; string comma-separated list of names of methods of type func() string whose results must be used (default &amp;ldquo;Error,String&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets use this code snippet from &lt;a href=&#34;https://twitter.com/francesc&#34;&gt;@francesc&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// extracted from tweet: https://twitter.com/francesc/status/491699441506586627
// filename: sample.go
package main

import &amp;quot;fmt&amp;quot;

func main() {
	a := 0
	if a != 1 || a != 2 { 
		 a++ 
	}

	fmt.Printf(&amp;quot;a = %s\n&amp;quot;, a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets see the tool in action:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go tool vet sample.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Vet&lt;/code&gt; reports two suspicious constructions. First it reports that the if-condition
is suspicious. It&amp;rsquo;s always &lt;code&gt;true&lt;/code&gt; since cannot be both. The second warning reports
that &lt;code&gt;%s&lt;/code&gt; is used with &lt;code&gt;integer&lt;/code&gt; type instead of &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sample.go:10: suspect or: a != 1 || a != 2
sample.go:14: arg a for printf verb %s of wrong type: int
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;golint&#34;&gt;Golint&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/golang/lint&#34;&gt;Golint&lt;/a&gt; differs from &lt;code&gt;gofmt&lt;/code&gt; and &lt;code&gt;govet&lt;/code&gt;. It prints out style mistakes.
&lt;code&gt;Golint&lt;/code&gt; is concerned with coding style. It is in use at Google, and it seeks
to match the accepted style of the open source Go project.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Golint&lt;/code&gt; make suggestions regarding source code. It is not perfect,
and has both false positives and false negatives. Do not consider its output as a truth.
It will never be trustworthy enough to be enforced automatically as part of a build process.&lt;/p&gt;

&lt;h4 id=&#34;installation&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;go get -u github.com/golang/lint/golint
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage&#34;&gt;Usage&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// analysis a particular package
$ golint package
// analysis a particular directory
$ golint directory 
// analyses a particualr files
$ golint files 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets &lt;code&gt;lint&lt;/code&gt; the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: hr.go
package hr

import &amp;quot;errors&amp;quot;

const MaxAge int = 70

type Person struct {
	Name string
	Age  int
}

func NewPerson(name string) (*Person, error) {
	if name == &amp;quot;&amp;quot; {
		return nil, errors.New(&amp;quot;Name is required&amp;quot;)
	} else {
		return &amp;amp;Person{Name: name}, nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The command tool give us the following sugestion to improve our source code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hr.go:5:6: exported type Person should have comment or be unexported
hr.go:9:1: exported function NewPerson should have comment or be unexported
hr.go:12:9: if block ends with a return statement, so drop this else and outdent its block
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Neat. Isn&amp;rsquo;t it?&lt;/p&gt;

&lt;h2 id=&#34;errcheck&#34;&gt;Errcheck&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://github.com/kisielk/errcheck&#34;&gt;errcheck&lt;/a&gt; command tools is a program that checks whether a source code has
unhandled errors.&lt;/p&gt;

&lt;h4 id=&#34;installation-1&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/kisielk/errcheck
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-1&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;The following flags can control the tool behavior (extracted from help doc):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-abspath&lt;/code&gt; print absolute paths to files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-asserts&lt;/code&gt; if true, check for ignored type assertion results&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-blank&lt;/code&gt; if true, check for errors assigned to blank identifier. By default is false.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ignore&lt;/code&gt; value comma-separated list of pairs in pkg:regex format.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-ignorepkg&lt;/code&gt; string comma-separated list of package paths to ignore&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-tags&lt;/code&gt; value space-separated list of build tags to include (default &amp;ldquo;&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-verbose&lt;/code&gt; produce more verbose logging&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Lets have the following snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: logger.go
package logger 

import &amp;quot;os&amp;quot;

func Log(path, data string) {
	file, _ := os.Open(path)
	file.Write([]byte(data))
	file.Close()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets do error handling analysis with &lt;code&gt;errcheck&lt;/code&gt; tool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Note that analyses of _ errors is skipped by default.
// We enable that by providing -blank flag.
$ errcheck -blank app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The following lines are reported as problematic:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;web/logger.go:6:8        file, _ := os.Open(path)
web/logger.go:7:12       file.Write([]byte(data))
web/logger.go:8:12       file.Close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;safesql&#34;&gt;SafeSQL&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/stripe/safesql&#34;&gt;SafeSQL&lt;/a&gt; is a static analysis command line
tool that protects against &lt;a href=&#34;https://en.wikipedia.org/wiki/SQL_injection&#34;&gt;SQL injections&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;installation-2&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/stripe/safesql
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-2&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;If SafeSQL passes, your application is safe from SQL injections, however there
are many safe programs which SafeSQL will declare potentially unsafe. There are
false positives due to the fact that &lt;code&gt;SafeSQL&lt;/code&gt; does not recursively trace down
query arguments through every function. Second there are many SQL statement to
represent compile time constants required for the static analysis algorithm.&lt;/p&gt;

&lt;p&gt;Lets see the tool in action with this code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package database

import (
	&amp;quot;database/sql&amp;quot;
	&amp;quot;log&amp;quot;
)

func Status(username string) string {
	db, err := sql.Open(&amp;quot;mysql&amp;quot;, &amp;quot;user:password@tcp(127.0.0.1:3306)/hello&amp;quot;)
	if err != nil {
		log.Fatal(err)
	}

	defer db.Close()
	sql := &amp;quot;SELECT * FROM user WHERE username=&#39;&amp;quot; + username + &amp;quot;&#39;&amp;quot;
	row := db.QueryRow(sql)

	var isLogged bool
	row.Scan(&amp;amp;isLogged)
	if isLogged {
		return &amp;quot;online&amp;quot;
	}

	return &amp;quot;offline&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It reports the following SQL injection:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Found 1 potentially unsafe SQL statements:
- /$GOPATH/db/database.go:16:20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It gives the following recommendation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Please ensure that all SQL queries you use are compile-time constants.
You should always use parameterized queries or prepared statements
instead of building queries from strings.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;defercheck&#34;&gt;Defercheck&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/opennota/check/&#34;&gt;Defercheck&lt;/a&gt; is command tool that checks for repeating &lt;code&gt;defer&lt;/code&gt; statements.&lt;/p&gt;

&lt;h4 id=&#34;installation-3&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/opennota/check/cmd/defercheck
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-3&#34;&gt;Usage&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ defercheck go/parser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It reports the following suspicious defer statement in parser package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/.../go/parser/parser.go:1929: Repeating defer p.closeScope() inside function parseSwitchStmt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;structcheck&#34;&gt;Structcheck&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/opennota/check/&#34;&gt;Structcheck&lt;/a&gt; is command tool that checks for unused field in structs.&lt;/p&gt;

&lt;h4 id=&#34;installation-4&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/opennota/check/cmd/structcheck
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-4&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;Lets check the &lt;code&gt;hr&lt;/code&gt; codesnippet that we used previously.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ structcheck -e hr 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Available command line flags are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt; Count assignments only&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; Report exported fields&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt; Load test files too&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It reports that the &lt;code&gt;Age&lt;/code&gt; field of &lt;code&gt;Person&lt;/code&gt; struct is unused:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hr: /$GOPATH/src/hr/hr.go:7:2: hr/hr.Person.Age
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;varcheck&#34;&gt;Varcheck&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/opennota/check/&#34;&gt;Varcheck&lt;/a&gt; command is doing the same analysis as &lt;code&gt;Structcheck&lt;/code&gt; but on global
variables and constants.&lt;/p&gt;

&lt;h4 id=&#34;installation-5&#34;&gt;Installation&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/opennota/check/cmd/varcheck
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;usage-5&#34;&gt;Usage&lt;/h4&gt;

&lt;p&gt;Lets inspect the &lt;code&gt;hr&lt;/code&gt; package again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// -e Report exported variables and constants
$ varcheck -e hr 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It finds that the &lt;code&gt;Age&lt;/code&gt; constant is not used:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hr: /$GOPATH/src/hr/hr.go:5:7: MaxAge
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/go/ssa&#34;&gt;Static single-assignment package&lt;/a&gt;
provides a very powerful framework for code analysis. It gives the opportunity
to build different tools that may increase the code quality and durability of
every &lt;code&gt;Go&lt;/code&gt; program. I am looking forward to see more and more command tools
that will bring our source code to the next level.&lt;/p&gt;

&lt;p&gt;The previous articles regarding tools in &lt;code&gt;Go&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.ralch.com/tutorial/golang-tools-refactoring/&#34;&gt;Golang refactoring tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.ralch.com/tutorial/golang-tools-comprehension/&#34;&gt;Golang code comprehension tools&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Golang code comprehension tools</title>
      <link>http://blog.ralch.com/tutorial/golang-tools-comprehension/</link>
      <pubDate>Sun, 06 Sep 2015 08:52:51 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-tools-comprehension/</guid>
      <description>

&lt;p&gt;Software engineers spend a greater part of time reading and understanding programs.
Indeed, most of the time it takes to develop a program is spent reading it and
making logical conclusion about what it does.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Go&lt;/code&gt; programmers are no exception. Thanks to &lt;a href=&#34;http://blog.ralch.com/tutorial/golang-tools-refactoring/&#34;&gt;gofmt&lt;/a&gt;
they should not worry about source code formatting. The machines are
better suited to analyse source code and accomplish comprehension tasks than us.&lt;/p&gt;

&lt;p&gt;In this article we will explore several of &lt;code&gt;Go&lt;/code&gt; comprehension tools that are
responsible for locating definitions, ascertaining types of expressions, deducing implementation
relation, computing method sets, finding callers/callees, jumping through channels,
understanding aliasing.&lt;/p&gt;

&lt;h2 id=&#34;oracle&#34;&gt;Oracle&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;oralce&lt;/code&gt; is a source analysis tool that answers question about your Go source code.
It is installed by executing this command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get golang.org/x/tools/cmd/oracle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;-pos&lt;/code&gt; flag is always required. It defines the current cursor position that
should be analysed. The expected value is a bytes offset from the beginning of
the file.&lt;/p&gt;

&lt;p&gt;These are the subcommands that determines the query to perform:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;callees&lt;/code&gt; show possible targets of selected function call&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callers&lt;/code&gt; show possible callers of selected function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;callstack&lt;/code&gt; show path from callgraph root to selected function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;definition&lt;/code&gt; show declaration of selected identifier&lt;/li&gt;
&lt;li&gt;&lt;code&gt;describe&lt;/code&gt; describe selected syntax: definition, methods, etc&lt;/li&gt;
&lt;li&gt;&lt;code&gt;freevars&lt;/code&gt; show free variables of selection&lt;/li&gt;
&lt;li&gt;&lt;code&gt;implements&lt;/code&gt; show relation for selected type or method&lt;/li&gt;
&lt;li&gt;&lt;code&gt;peers&lt;/code&gt; show send/receive corresponding to selected channel op&lt;/li&gt;
&lt;li&gt;&lt;code&gt;referrers&lt;/code&gt; show all refs to entity denoted by selected identifier&lt;/li&gt;
&lt;li&gt;&lt;code&gt;what&lt;/code&gt; show basic information about the selected syntax node&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;-format&lt;/code&gt; flag set the output format to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;plain&lt;/code&gt; an editor-friendly format in which every line of output&lt;/li&gt;
&lt;li&gt;&lt;code&gt;json&lt;/code&gt; structured data in JSON syntax.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xml&lt;/code&gt; structured data in XML syntax.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall, the tools provides an friendly interface for adopting it in different
development editor: &lt;a href=&#34;https://github.com/fatih/vim-go&#34;&gt;Vim&lt;/a&gt;, &lt;a href=&#34;https://www.gnu.org/software/emacs/&#34;&gt;Emacs&lt;/a&gt;,
&lt;a href=&#34;https://atom.io&#34;&gt;Atom&lt;/a&gt;, IntelliJ and etc.&lt;/p&gt;

&lt;p&gt;Let see &lt;code&gt;oracle&lt;/code&gt; in action:&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/F0ZLIxKWSYo&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;


&lt;h2 id=&#34;pythia&#34;&gt;Pythia&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Pythia&lt;/code&gt; is a browser based user interface for oracle. It is based on
the following packages:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/oracle&#34;&gt;oracle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/golang.org/x/tools/godoc/static&#34;&gt;godoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Pythia&lt;/code&gt; is installed with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/fzipp/pythia
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;pythia&lt;/code&gt; command tool now can be found in &lt;code&gt;$GOPATH/bin/pythia&lt;/code&gt;. A specific
package can be opened with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pythia net/http 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By default the command opens your default browser:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/golang-pythia-in-action.png&#34; alt=&#34;Pythia in Action&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;This can be disabled with &lt;code&gt;-open&lt;/code&gt; flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pythia -open=false net/http
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default listening port is &lt;code&gt;:8080&lt;/code&gt;. It can be changed via &lt;code&gt;-http&lt;/code&gt; flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pythia -http :9876 net/http
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The packages can be filtered out on their &lt;a href=&#34;http://blog.ralch.com/tutorial/golang-conditional-compilation/&#34;&gt;build tags&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ pythia -tags=unix net/http
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;godepgraph&#34;&gt;Godepgraph&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Godepgraph&lt;/code&gt; is a program for generating a dependency graph of Go packages.
Use &lt;code&gt;go get&lt;/code&gt; command to install it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get github.com/kisielk/godepgraph
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usually the tool is combined with &lt;code&gt;dot&lt;/code&gt; command (graphviz CLI):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// this command will generate dependency graph as svg image
// -s ingores the builtin packages
// -horizontal layout the graphics horizontally
$ godepgraph -s -horizontal github.com/codegangsta/gin | dot -Tsvg -o gin-godepgraph.svg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The command above will produce the following graphics:&lt;/p&gt;


&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/golang/golang-godepgraph.svg&#34; alt=&#34;Godepgraph in Action&#34; /&gt;
    
    
&lt;/figure&gt;


&lt;p&gt;The &lt;code&gt;godepgraph&lt;/code&gt; tools can be controlled with these flags:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; show dependencies of packages in the Go standard library&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-horizontal&lt;/code&gt; lay out the dependency graph horizontally instead of vertically&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; string a comma-separated list of packages to ignore&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt; string a comma-separated list of prefixes to ignore&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt; ignore packages in the Go standard library&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt; include test packages&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-tags&lt;/code&gt; string a comma-separated list of build tags to consider satisfied during the build&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Even though Golang does not have dedicated development environment, software engineers
can be very product by adopting some of the comprehensive tools mentioned in this article.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang refactoring tools</title>
      <link>http://blog.ralch.com/tutorial/golang-tools-refactoring/</link>
      <pubDate>Sun, 30 Aug 2015 12:41:34 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-tools-refactoring/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt; language provides many useful tools as part of its
development eco system. We will explore most of them in the upcoming blog posts.
But in the article lets focus on refactoring tools.&lt;/p&gt;

&lt;h2 id=&#34;gofmt&#34;&gt;Gofmt&lt;/h2&gt;

&lt;p&gt;In average programming languages developers can adapt to different formatting
styles. Common problem is how to approach unknown code base without a long
prescriptive style guide.&lt;/p&gt;

&lt;p&gt;Go takes an unusual approach and keep this responsibility to format the source code
for you. The &lt;code&gt;gofmt&lt;/code&gt; program (available as &lt;code&gt;go fmt&lt;/code&gt;, which examines
on the package level rather than source file level) reads a Go syntax and reformat
your program in a standard coding style. In addition, it provides some additional
refactoring capabilities, which will explore in detail.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The -w flag overwrites the files instead of prints out the result on the screen
$ gofmt -w message.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It formats the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: message.go
package message
import &amp;quot;fmt&amp;quot;
func FormatMessage(name string) string{
if len(name) == 0 { return &amp;quot;Welcome&amp;quot; } else { return fmt.Sprintf(&amp;quot;Hi, %s&amp;quot;, name) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: message.go
package message

import &amp;quot;fmt&amp;quot;

func FormatMessage(name string) string {
	if len(name) == 0 {
		return &amp;quot;Welcome&amp;quot;
	} else {
		return fmt.Sprintf(&amp;quot;Hi, %s&amp;quot;, name)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that &lt;code&gt;gofmt&lt;/code&gt; uses tabs for indentation and
blanks for alignment.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The code is reformatted to obey all &lt;code&gt;Go&lt;/code&gt; coding style standards. It does not rename
any variables and functions. There is a tool that do static analyses on your code.
We will talk about it in one of the next articles.&lt;/p&gt;

&lt;p&gt;These are the flags supported by &lt;code&gt;gofmt&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; prints diffs to standard out when file formatting is changed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt; print all errors&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt; prints the filename to standard out when file formatting is changed&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; applies the rewrite rule to the source before reformatting.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt; simplifies code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt; overwrites file with its formatted version&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the next two paragraphs we will explore how to simplify and apply rewrites rules
to a source code.&lt;/p&gt;

&lt;p&gt;Simplifing source code is applied when &lt;code&gt;-s&lt;/code&gt; flag is presented. It improves the
code readability by replacing blocks of code with their sipliefied syntax version.&lt;/p&gt;

&lt;p&gt;Executing &lt;code&gt;go fmt -s -w transport.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: transport.go
package transport

import &amp;quot;fmt&amp;quot;

type Endpoint struct {
	Protocol string
	Host     string
	Port     int
}

var endpoints []Endpoint = []Endpoint{
	Endpoint{
		Protocol: &amp;quot;HTTP&amp;quot;,
		Host:     &amp;quot;localhost&amp;quot;,
		Port:     80},
	Endpoint{
		Protocol: &amp;quot;SSH&amp;quot;,
		Host:     &amp;quot;10.10.5.9.xip.io&amp;quot;,
		Port:     22}}

func ListEndpoints(startIndex int) {
	for index, _ := range endpoints[startIndex:len(endpoints)] {
		endpoint := endpoints[index]
		fmt.Printf(&amp;quot;Priority: %d Procotol: %s Address: %s:%d\n&amp;quot;,
			index, endpoint.Protocol, endpoint.Host, endpoint.Port)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The package will be simplified to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: transport.go
package transport

import &amp;quot;fmt&amp;quot;

type Endpoint struct {
	Protocol string
	Host     string
	Port     int
}

var endpoints []Endpoint = []Endpoint{
	{Protocol: &amp;quot;HTTP&amp;quot;,
		Host: &amp;quot;localhost&amp;quot;,
		Port: 80},
	{Protocol: &amp;quot;SSH&amp;quot;,
		Host: &amp;quot;10.10.5.9.xip.io&amp;quot;,
		Port: 22}}

func ListEndpoints(startIndex int) {
	for index := range endpoints[startIndex:] {
		endpoint := endpoints[index]
		fmt.Printf(&amp;quot;Priority: %d Procotol: %s Address: %s:%d\n&amp;quot;,
			index, endpoint.Protocol, endpoint.Host, endpoint.Port)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are the applied rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;An array, slice, or map composite literal of the form &lt;code&gt;[]T{T{}, T{}}&lt;/code&gt;
will be simplified to &lt;code&gt;[]T{{}, {}}&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A slice expression of the form &lt;code&gt;s[a:len(s)]&lt;/code&gt; will be simplified to &lt;code&gt;s[a:]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A range of the form &lt;code&gt;for x, _ = range v {...}&lt;/code&gt; will be simplified to &lt;code&gt;for x = range v {...}&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A range of the form &lt;code&gt;for _ = range v {...}&lt;/code&gt; will be simplified to &lt;code&gt;for range v {...}&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To define specified rewrite rule the &lt;code&gt;-r&lt;/code&gt; flag must be used. It should be in
the following format:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pattern -&amp;gt; replacement
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both pattern and replacement must be valid &lt;code&gt;Go&lt;/code&gt; expressions. The pattern serves
as wildcards matching arbitrary sub-expressions. They will be substituted for
the same identifiers in the replacement.&lt;/p&gt;

&lt;p&gt;Lets rename &lt;code&gt;Endpoint&lt;/code&gt; struct to &lt;code&gt;Server&lt;/code&gt; in &lt;code&gt;transport&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gofmt -r &#39;Endpoint -&amp;gt; Server&#39; -w transport.go
$ gofmt -r &#39;endpoints -&amp;gt; servers&#39; -w transport.go
$ gofmt -r &#39;ListEndpoints -&amp;gt; ListServers&#39; -w transport.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result of this operation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: transport.go
package transport

import &amp;quot;fmt&amp;quot;

type Server struct {
	Protocol string
	Host     string
	Port     int
}

var servers []Server = []Server{
	{Protocol: &amp;quot;HTTP&amp;quot;,
		Host: &amp;quot;localhost&amp;quot;,
		Port: 80},
	{Protocol: &amp;quot;SSH&amp;quot;,
		Host: &amp;quot;10.10.5.9.xip.io&amp;quot;,
		Port: 22}}

func ListServers(startIndex int) {
	for index := range servers[startIndex:] {
		endpoint := servers[index]
		fmt.Printf(&amp;quot;Priority: %d Procotol: %s Address: %s:%d\n&amp;quot;,
			index, endpoint.Protocol, endpoint.Host, endpoint.Port)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gorename&#34;&gt;Gorename&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;gorename&lt;/code&gt; is another tool for code refactoring. It command performs precise
type-safe renaming of identifiers in Go source code. It is installed with
the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get golang.org/x/tools/refactor/rename
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets use the tool with the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// package: university
package main

import &amp;quot;fmt&amp;quot;

type Student struct {
	Firstname string
	Surename  string
}

func (s *Student) Fullname() string {
	return fmt.Sprintf(&amp;quot;%s %s&amp;quot;, s.Firstname, s.Surename)
}

func main() {
	students := []Student{
		{Firstname: &amp;quot;John&amp;quot;,
			Surename: &amp;quot;Freeman&amp;quot;},
		{Firstname: &amp;quot;Jack&amp;quot;,
			Surename: &amp;quot;Numan&amp;quot;},
	}

	for _, s := range students {
		fmt.Println(s.Fullname())
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Renaming &lt;code&gt;Fullname&lt;/code&gt; function of &lt;code&gt;Student&lt;/code&gt; struct to &lt;code&gt;String&lt;/code&gt; can be done by
executing &lt;code&gt;gorename&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gorename -from &#39;&amp;quot;university&amp;quot;.Student.Fullname&#39; -to String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-from&lt;/code&gt; flag must obey the following format specifies the object to rename
using a query notation like that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;encoding/json&amp;quot;.Decoder.Decode        method of package-level named type
(*&amp;quot;encoding/json&amp;quot;.Decoder).Decode     ditto, alternative syntax
&amp;quot;encoding/json&amp;quot;.Decoder.buf           field of package-level named struct type
&amp;quot;encoding/json&amp;quot;.HTMLEscape            package member (const, func, var, type)
&amp;quot;encoding/json&amp;quot;.Decoder.Decode::x     local object x within a method
&amp;quot;encoding/json&amp;quot;.HTMLEscape::x         local object x within a function
&amp;quot;encoding/json&amp;quot;::x                    object x anywhere within a package
json.go::x                            object x within file json.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-to&lt;/code&gt; flag defines the new name of the object.&lt;/p&gt;

&lt;h2 id=&#34;eg&#34;&gt;Eg&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Eg&lt;/code&gt; command is a tool that implements example-based refactoring of expressions.
The transformation is specified as a Go file defining two functions,
&lt;code&gt;before&lt;/code&gt; and &lt;code&gt;after&lt;/code&gt; of identical types. The parameters of both functions are
wildcards that may match any expression assignable to that type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package P
import ( &amp;quot;errors&amp;quot;; &amp;quot;fmt&amp;quot; )
// specifies a match pattern like:
func before(s string) error { return fmt.Errorf(&amp;quot;%s&amp;quot;, s) }
// specifies its replacement like:
func after(s string)  error { return errors.New(s) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tool analyses all Go code in the packages specified by the
arguments, replacing all occurrences of the pattern with the
substitution.&lt;/p&gt;

&lt;p&gt;Lets apply the below example to &lt;code&gt;university&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: stringfix.go
package P

import &amp;quot;fmt&amp;quot;

// specifies a match pattern like:
func before(x, y string) string { return fmt.Sprintf(&amp;quot;%s %s&amp;quot;, x, y) }

// specifies its replacement like:
func after(x, y string) string { return x + &amp;quot; &amp;quot; + y }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To do that we should execute &lt;code&gt;eg&lt;/code&gt; command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// -t specifies the template file
// -w specifies that the matched files must be overwritten
$ eg -t stringfix.go -w  -- university
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tool changes the implementation of &lt;code&gt;String&lt;/code&gt; function of &lt;code&gt;Student&lt;/code&gt; package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// package: university
// struct: Student
// filename: main.go
func (s *Student) Fullname() string {
	return s.Firstname + &amp;quot; &amp;quot; + s.Surename
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As part of our job is not only to develop new features, but also improve
existing code base. &lt;code&gt;Gofmt&lt;/code&gt;, &lt;code&gt;gorename&lt;/code&gt; and &lt;code&gt;eg&lt;/code&gt; are tools that can help to
boost the productivity and keep source code in well formatted shape
that fits the &lt;code&gt;Go&lt;/code&gt; coding style standard.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Sharing Golang packages to C and Go</title>
      <link>http://blog.ralch.com/tutorial/golang-sharing-libraries/</link>
      <pubDate>Sun, 23 Aug 2015 11:04:50 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-sharing-libraries/</guid>
      <description>

&lt;p&gt;The latest &lt;a href=&#34;https://blog.golang.org/go1.5&#34;&gt;Go 1.5&lt;/a&gt; version is out. As part of
the &lt;a href=&#34;https://golang.org/doc/go1.5&#34;&gt;new features&lt;/a&gt;, &lt;code&gt;Go compiler&lt;/code&gt; can compile
packages as a shared libraries.&lt;/p&gt;

&lt;p&gt;It accepts &lt;code&gt;-buildmode&lt;/code&gt; argument that determines how a package is compiled.
These are the following options:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;archive&lt;/code&gt;: Build the listed non-main packages into .a files. Packages named
main are ignored.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c-archive&lt;/code&gt;: Build the listed main package, plus all packages it imports,
into a C archive file.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c-shared&lt;/code&gt;: Build the listed main packages, plus all packages that they import,
into C shared libraries.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shared&lt;/code&gt;: Combine all the listed non-main packages into a single shared library.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exe&lt;/code&gt;: Build the listed main packages and everything they import into executables.
Packages not named main are ignored.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;By default, listed main packages are built into executables
and listed non-main packages are built into .a files.&lt;/p&gt;

&lt;p&gt;In this article we will explore two major ways to share libraries between Go and C:&lt;/p&gt;

&lt;h2 id=&#34;using-shared-library-in-go&#34;&gt;Using shared library in Go&lt;/h2&gt;

&lt;p&gt;Assume that &lt;code&gt;GOPATH&lt;/code&gt; contains this structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
 calc
  calc.go
 cashier
     main.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;calc&lt;/code&gt; package contains a set of functions that do arithmetic opertaions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: calc.go
package calc

func Sum(x, y int) int {
    return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before compile any shared library, the standard builtin packages should be installed
as shared library. This will allow any other shared library to link with them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go install -buildmode=shared -linkshared std
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the &lt;code&gt;calc&lt;/code&gt; package can be compiled as shared library linked to &lt;code&gt;std&lt;/code&gt; libraries:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go install -buildmode=shared -linkshared calc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Due to a &lt;a href=&#34;https://github.com/golang/go/issues/12236&#34;&gt;issue&lt;/a&gt;, building and installing
shared library should be from &lt;code&gt;$GOPATH/src&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Lets use the shared library &lt;code&gt;calc&lt;/code&gt; in the &lt;code&gt;cashier&lt;/code&gt; application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// package: cashier
// filename: main.go
package main

import &amp;quot;calc&amp;quot;
import &amp;quot;fmt&amp;quot;

func main() {
  fmt.Println(&amp;quot;Cashier Application&amp;quot;)
    fmt.Printf(&amp;quot;Result: %d\n&amp;quot;, calc.Sum(5, 10))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The application should be compiled and linked with &lt;code&gt;calc&lt;/code&gt; library
with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go build -linkshared -o app cashier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output of executing the application is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./app
Cashier Application
Result: 15
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that this feature is available on &lt;code&gt;linux/amd64&lt;/code&gt; platform or when &lt;code&gt;gccgo&lt;/code&gt;
compiler is used.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;using-shared-go-library-in-c&#34;&gt;Using shared Go library in C&lt;/h2&gt;

&lt;p&gt;Go functions can be executed from C applications. They should be
exported by using the following comment line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//export &amp;lt;your_function_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code snippet below, the function &lt;code&gt;SayHello&lt;/code&gt; and &lt;code&gt;SayBye&lt;/code&gt; are exported:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// package name: nautilus
package main

import &amp;quot;C&amp;quot;
import &amp;quot;fmt&amp;quot;

//export SayHello
func SayHello(name string) {
	fmt.Printf(&amp;quot;Nautilus says: Hello, %s!\n&amp;quot;, name)
}

//export SayBye
func SayBye() {
	fmt.Println(&amp;quot;Nautilus says: Bye!&amp;quot;)
}

func main() {
	// We need the main function to make possible
	// CGO compiler to compile the package as C shared library
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The packaged should be compiled with &lt;code&gt;buildmode&lt;/code&gt; flags &lt;code&gt;c-shared&lt;/code&gt; or &lt;code&gt;c-archive&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// as c-shared library
$ go build -buildmode=c-shared -o nautilus.a nautilus.go
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// as c-archive 
$ go build -buildmode=c-archive -o nautilus.a nautilus.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As result the &lt;code&gt;GO&lt;/code&gt; compiler will produce a static/dynamic &lt;code&gt;C&lt;/code&gt; library &lt;code&gt;nautilus.a&lt;/code&gt; and
header file &lt;code&gt;nautilus.h&lt;/code&gt;. The header file contains type definitions that marshall
and unmarshall data between &lt;code&gt;Go&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef signed char GoInt8;
typedef unsigned char GoUint8;
typedef short GoInt16;
typedef unsigned short GoUint16;
typedef int GoInt32;
typedef unsigned int GoUint32;
typedef long long GoInt64;
typedef unsigned long long GoUint64;
typedef GoInt64 GoInt;
typedef GoUint64 GoUint;
typedef __SIZE_TYPE__ GoUintptr;
typedef float GoFloat32;
typedef double GoFloat64;
typedef __complex float GoComplex64;
typedef __complex double GoComplex128;
typedef struct { char *p; GoInt n; } GoString;
typedef void *GoMap;
typedef void *GoChan;
typedef struct { void *t; void *v; } GoInterface;
typedef struct { void *data; GoInt len; GoInt cap; } GoSlice;

#endif

/* End of boilerplate cgo prologue.  */

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif


extern void SayHello(GoString p0);

extern void SayBye();

#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The header file &lt;code&gt;nautilus.h&lt;/code&gt; shoulde be imported from every &lt;code&gt;C&lt;/code&gt; application
that executed &lt;code&gt;SayHello&lt;/code&gt; and &lt;code&gt;SayBye&lt;/code&gt; functions.&lt;/p&gt;

&lt;p&gt;In the example below, the &lt;code&gt;SayHello&lt;/code&gt; function is called with parameter of type
&lt;code&gt;GoString&lt;/code&gt;. It includes &lt;code&gt;char*&lt;/code&gt; field and its length.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: _wale.c
#include &amp;quot;nautilus.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;

int main() {
  printf(&amp;quot;This is a C Application.\n&amp;quot;);
  GoString name = {&amp;quot;Jack&amp;quot;, 4};
  SayHello(name);
  SayBye();
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;_wale.c&lt;/code&gt; file is compiled with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gcc -o _wale _wale.c nautilus.a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Execution produce the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./wale
This is a C Application.
Nautilus says: Hello, Jack!
Nautilus says: Bye!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Sharing libraries between &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;Go&lt;/code&gt; gives opportunity to build greater and better
application by using the best from both worlds. This provides to a legacy system
a modern language that can improve their maintainance costs and business needs.
It maximize code reusability in the &lt;code&gt;Go&lt;/code&gt; ecosystem.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Conditional compilation in Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-conditional-compilation/</link>
      <pubDate>Sun, 16 Aug 2015 08:40:35 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-conditional-compilation/</guid>
      <description>

&lt;p&gt;When developing Go package or application that depends on specific features
of the underlying platform or architecture it is often necessary
to use a specialised implementation.&lt;/p&gt;

&lt;p&gt;There are two parts of Go conditional compilation system, which we will now
explore in more detail.&lt;/p&gt;

&lt;h2 id=&#34;build-constraints&#34;&gt;Build constraints&lt;/h2&gt;

&lt;p&gt;A build constraints (known as build tags) is an optional top line comment that
starts with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build

package api 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declaration of build constraints follows the following rules:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Each tag is alphanumeric word&lt;/li&gt;
&lt;li&gt;Tag preceded by &lt;code&gt;!&lt;/code&gt; defines its negation.&lt;/li&gt;
&lt;li&gt;A build constraint is evaluated as the OR of space-separated options.&lt;/li&gt;
&lt;li&gt;Each option evaluates as the AND of its comma-separated terms.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That means if we have the following build constraint:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build linux,386 darwin,!cgo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will be evaluated by the compilation system as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(linux AND 386) OR (darwin AND (NOT cgo))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A file can have multiple build constraints:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build linux freebsd
// +build 386

package api
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The evaluated constraint is a logical &lt;code&gt;AND&lt;/code&gt; of the individual build tags:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(linux OR freebsd) AND 386
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note that the build tags do not have strict validation. Be aware that they
should be formatted as the provided samples. In addition the last build tags should
be associated with a trailing new line. That makes it non-associated with any declaration.
Fortunately you can verify them by using &lt;code&gt;go vet&lt;/code&gt; tool.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;file-suffixes&#34;&gt;File suffixes&lt;/h2&gt;

&lt;p&gt;The second option for conditional compilation is the name of the
source file itself. This approach is simpler than build tags, and allows
the Go build system to exclude files without having to process the file.&lt;/p&gt;

&lt;p&gt;We should add one of the following suffixes to desired files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;*_GOOS // operation system
*_GOARCH // platform architecture
*_GOOS_GOARCH // both combined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are all available architectures and operation system supported by Go
build system:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;GOOS&lt;/th&gt;
&lt;th&gt;GOARCH&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;darwin&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dragonfly&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dragonfly&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;freebsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;linux&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;netbsd&lt;/td&gt;
&lt;td&gt;arm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;openbsd&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;plan9&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;plan9&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;solaris&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;windows&lt;/td&gt;
&lt;td&gt;386&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;windows&lt;/td&gt;
&lt;td&gt;amd64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Examples for such a files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;container_windows.go // only builds on windows system
container_linux.go // only builds on linux system
container_freebsd_386.go // only builds on FreeBSD system with 386 architecture
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to exclude a file from compilation, you should use &lt;code&gt;ignore&lt;/code&gt; build
constraint:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// +build ignore

package api
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;test-files&#34;&gt;Test files&lt;/h3&gt;

&lt;p&gt;Test files also support build constraints and file suffixes. They behave in the same
manner as other Go source files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;container_windows_test.go // windows specific container tests
container_linux_test.go // linux specific container tests
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;experimenting-with-c-c-preprocessor-and-go&#34;&gt;Experimenting with C/C++ preprocessor and Go&lt;/h2&gt;

&lt;p&gt;Go does not have a preprocessor to control the inclusion of platform specific code.
Even though C preprocessor is intended to be used only with C, C++, and Objective-C source code,
we will use it as a general text processor of Go source code.&lt;/p&gt;

&lt;p&gt;Lets have the following code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: app.pgo
package main

import &amp;quot;fmt&amp;quot;
#ifdef PRINT_DATE
import &amp;quot;time&amp;quot;
#endif

func main() {
  fmt.Println(&amp;quot;Application is executed.&amp;quot;)
#ifdef PRINT_DATE
  fmt.Printf(&amp;quot;Current Date: %s\n&amp;quot;, time.Now().String())
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we execute the C preprocessor on &lt;code&gt;app.pgo&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// -P disable linemaker output.
$ cpp -P app.pgo app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will produce a new file &lt;code&gt;app.go&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: app.go
package main

import &amp;quot;fmt&amp;quot;

func main() {
  fmt.Println(&amp;quot;Application is executed.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we define &lt;code&gt;PRINT_DATE&lt;/code&gt; variable for the preprocessor by using &lt;code&gt;-D&lt;/code&gt; flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cpp -DPRINT_DATE -P app.pgo app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will produce a new file that includes additional print statment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// filename: app.go
package main

import &amp;quot;fmt&amp;quot;
import &amp;quot;time&amp;quot;

func main() {
  fmt.Println(&amp;quot;Application is executed.&amp;quot;)
  fmt.Printf(&amp;quot;Current Date: %s\n&amp;quot;, time.Now().String())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can combine the preprocessor operation with go build step:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cpp -DPRINT_DATE -P app.pgo app.go | go build app.go
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;verdict&#34;&gt;Verdict&lt;/h2&gt;

&lt;p&gt;We should aim to develop and build our Go applications by following Go idioms.
If the source file targets a specific platform, we should choose file suffix
approach. Otherwise, if the source file is applicable for multiple platforms and
we want to exclude a specific feature or platform, we should use build constraints instead.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Delve: Next generation debugger for Golang</title>
      <link>http://blog.ralch.com/tutorial/golang-debug-with-delve/</link>
      <pubDate>Sat, 08 Aug 2015 20:42:49 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-debug-with-delve/</guid>
      <description>

&lt;p&gt;In my previous &lt;a href=&#34;http://bit.ly/1DjLPNp&#34;&gt;post&lt;/a&gt; I demonstrated how you can debug
golang applications with &lt;code&gt;LLDB&lt;/code&gt;. In this article I will illustrate
the most recent debugger for Go: &lt;a href=&#34;https://github.com/derekparker/delve&#34;&gt;Delve&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The debugger is a community effort to bring a debugger in the toolchain of every &lt;code&gt;Go&lt;/code&gt; developer.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s written in &lt;code&gt;Go&lt;/code&gt; to debug &lt;code&gt;Go&lt;/code&gt; code. It&amp;rsquo;s still in active development, but
we can still benefit from its basic features.&lt;/p&gt;

&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;You should install &lt;code&gt;Delve&lt;/code&gt; with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go get -u github.com/derekparker/delve/cmd/dlv 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you need at least &lt;code&gt;Go 1.4&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;installation-linux&#34;&gt;Installation: Linux&lt;/h4&gt;

&lt;p&gt;In Linux you should NOT do anything else further. You are ready.&lt;/p&gt;

&lt;h4 id=&#34;installation-macosx&#34;&gt;Installation: MacOSX&lt;/h4&gt;

&lt;p&gt;If you are using &lt;code&gt;MacOSX&lt;/code&gt; as me, you need a self-signed certificate to sign the delve binary.&lt;/p&gt;

&lt;p&gt;You should create a new certificate by using application &amp;ldquo;Keychain Access&amp;rdquo;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Choose a certificate name, set &amp;ldquo;Identity Type&amp;rdquo; to &amp;ldquo;Self Signed Root&amp;rdquo;, set &amp;ldquo;Certificate Type&amp;rdquo;
to &lt;code&gt;Code Signing&lt;/code&gt; and select the &lt;code&gt;Let me override defaults&lt;/code&gt;:

&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/debugger/certificate-name.png&#34; alt=&#34;Certificate Name&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Continue to a certificate information wizard step. If you email address is missing, please
fill the required field:

&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/debugger/certificate-info.png&#34; alt=&#34;Certificate Info&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Click several times on Continue until you get to
the &amp;ldquo;Specify a Location For The Certificate&amp;rdquo; screen, then set &amp;ldquo;Keychain to System&amp;rdquo;.

&lt;figure &gt;
    
        &lt;img src=&#34;http://blog.ralch.com/media/debugger/certificate-keychain.png&#34; alt=&#34;Certificate Keychain&#34; /&gt;
    
    
&lt;/figure&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Then we need sign the binary by using the created certificate. In order to do that we should
execute the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# CERT=&amp;lt;your_ceriticate_name&amp;gt; make install 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need more detailed guidelines, you should follow &lt;a href=&#34;https://github.com/derekparker/delve/wiki/Building&#34;&gt;the official documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You can watch the following video that demonstrates the installation process:&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/4ndjybtBg74&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;


&lt;h3 id=&#34;integration&#34;&gt;Integration&lt;/h3&gt;

&lt;p&gt;Right now the debugger does not have integration with any IDE. Nevertheless, the contributors
are working hard to release an API interface that will allow that. For now &lt;code&gt;Delve&lt;/code&gt; can
be started from a command line.&lt;/p&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting started&lt;/h3&gt;

&lt;p&gt;Compile, run, and attach in one step:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dlv run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run program with tracepoints set at functions matching [regexp]:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dlv trace [regexp]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compile test binary, start and attach:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dlv test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Provide the application path you want to debug:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dlv path/to/program
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Provide the running application process id:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo dlv attach 47478 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Delve will pass any arguments after &lt;code&gt;dlv run|test|trace&lt;/code&gt; to the newly created process:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dlv run -- -http=:6060
$ dlv run arg1 -- -flag1 -flag2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;commands&#34;&gt;Commands&lt;/h3&gt;

&lt;p&gt;In debug session, you can use the following commands:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;help&lt;/code&gt; - Prints the help message.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;restart&lt;/code&gt; - Restarts the process, killing the current one if it is running.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;break (break &amp;lt;address&amp;gt; [-stack &amp;lt;n&amp;gt;|-goroutine|&amp;lt;variable name&amp;gt;]*)&lt;/code&gt; - Set a breakpoint. Example: &lt;code&gt;break foo.go:13&lt;/code&gt; or &lt;code&gt;break main.main&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trace&lt;/code&gt; - Set a tracepoint. Syntax identical to breakpoints.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;continue&lt;/code&gt; - Run until breakpoint or program termination.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;step&lt;/code&gt; - Single step through program.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next&lt;/code&gt; - Step over to next source line.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;threads&lt;/code&gt; - Print status of all traced threads.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thread $tid&lt;/code&gt; - Switch to another thread.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;goroutines&lt;/code&gt; - Print status of all goroutines.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;breakpoints&lt;/code&gt; - Print information on all active breakpoints.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;print $var&lt;/code&gt; - Evaluate a variable.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;info $type [regex]&lt;/code&gt; - Outputs information about the symbol table. An optional regex filters the list. Example &lt;code&gt;info funcs unicode&lt;/code&gt;. Valid types are:

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;args&lt;/code&gt; - Prints the name and value of all arguments to the current function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;funcs&lt;/code&gt; - Prints the name of all defined functions&lt;/li&gt;
&lt;li&gt;&lt;code&gt;locals&lt;/code&gt; - Prints the name and value of all local variables in the current context&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sources&lt;/code&gt; - Prints the path of all source files&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vars&lt;/code&gt; - Prints the name and value of all package variables in the app. Any variable that is not local or arg is considered a package variables&lt;/li&gt;
&lt;li&gt;&lt;code&gt;regs&lt;/code&gt; - Prints the contents of CPU registers.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stack [ &amp;lt;depth&amp;gt; [ &amp;lt;goroutine id&amp;gt; ] ]&lt;/code&gt; - Prints the stacktrace of the current goroutine, up to &lt;code&gt;&amp;lt;depth&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;lt;depth&amp;gt;&lt;/code&gt; defaults to 10, pass a second argument to print the stacktrace of a different goroutine.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exit&lt;/code&gt; - Exit the debugger.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;demo&#34;&gt;Demo&lt;/h3&gt;

&lt;p&gt;In the demo video, I am using the &lt;a href=&#34;https://gist.github.com/svett/4b95e8d1631fd0a93dfe&#34;&gt;same application&lt;/a&gt; that I debugged in &lt;a href=&#34;http://bit.ly/1DjLPNp&#34;&gt;the LLDB article&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/zgLjVD5ZSOc&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Note that parts of this article are taken from the official &lt;code&gt;Delve&lt;/code&gt;
&lt;a href=&#34;https://github.com/derekparker/delve/wiki/Commands&#34;&gt;commands&lt;/a&gt; documentation and
&lt;a href=&#34;https://github.com/derekparker/delve/wiki/Usage&#34;&gt;usage&lt;/a&gt; documentation.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Debug Golang applications: LLDB</title>
      <link>http://blog.ralch.com/tutorial/golang-debug-with-lldb/</link>
      <pubDate>Sat, 01 Aug 2015 16:47:06 &#43;0100</pubDate>
      <author>Svett Ralchev</author>
      <guid>http://blog.ralch.com/tutorial/golang-debug-with-lldb/</guid>
      <description>

&lt;p&gt;Even that ease and simplicity of using &lt;code&gt;go&lt;/code&gt; are one of its main advanatages,
there are difficulties in debugging applications written in &lt;code&gt;go&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The lack of mature tools (like supported &lt;code&gt;vim&lt;/code&gt; plugin) push most of us to use
logging techniques to inspect and track down issues.&lt;/p&gt;

&lt;p&gt;In this article, I will demonstrates how you can use &lt;code&gt;vim&lt;/code&gt; and &lt;code&gt;lldb&lt;/code&gt; to debug
a go application. Before that you should make the application capable for debugging.&lt;/p&gt;

&lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;

&lt;p&gt;You should compile the application by emitting the debug information and disable inlining.
The &lt;code&gt;-N&lt;/code&gt; flag enables debug information emitting and &lt;code&gt;-l&lt;/code&gt; disables compiler inlining:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;go build -gcflag &#39;-N -l&#39; &amp;lt;file_or_package&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The compiled binary supports &lt;a href=&#34;https://en.wikipedia.org/wiki/DWARF&#34;&gt;DWARF&lt;/a&gt; debugging
data format, which is supported by debuggers as &lt;a href=&#34;https://en.wikipedia.org/wiki/GNU_Debugger&#34;&gt;GDB&lt;/a&gt;
and &lt;a href=&#34;https://goo.gl/fgiab0&#34;&gt;LLDB&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You should install &lt;code&gt;vim-lldb&lt;/code&gt; plugin from &lt;a href=&#34;https://github.com/gilligan/vim-lldb&#34;&gt;here&lt;/a&gt;.
The easiest way to install it by using package manager as &lt;code&gt;bundle&lt;/code&gt;. You should
add &lt;code&gt;Bundle &amp;quot;gilligan/vim-lldb&amp;quot;&lt;/code&gt; in your bundle list.&lt;/p&gt;

&lt;p&gt;Then you can use the following commands and shortcuts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ltarget&lt;/code&gt; specifies the binary that we are going to debug&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lbreakpoint&lt;/code&gt; sets a breakpoint in file on particular line (&lt;code&gt;&amp;lt;leader&amp;gt;lb&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lrun&lt;/code&gt; starts the debugger (&lt;code&gt;&amp;lt;leader&amp;gt;lr&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lstep&lt;/code&gt; does a source level single step in the current thread. (&lt;code&gt;&amp;lt;leader&amp;gt;ls&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lfinish&lt;/code&gt; steps out of the currently selected frame. (&lt;code&gt;&amp;lt;leader&amp;gt;lo&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lnext&lt;/code&gt; does a source level single step over in the current thread. (&lt;code&gt;&amp;lt;leader&amp;gt;ln&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lcontinue&lt;/code&gt; continues execution until next breakpoint. (&lt;code&gt;&amp;lt;leader&amp;gt;lc&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lprint&lt;/code&gt; evaluates a generalized expression in the current frame. (&lt;code&gt;&amp;lt;leader&amp;gt;lp&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lframe variable&lt;/code&gt; prints the frame local variables (&lt;code&gt;&amp;lt;leader&amp;gt;lv&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can add my extra shortcuts in your &lt;code&gt;.vimrc&lt;/code&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;lr :Lrun&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;lb :Lbreakpoint&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;lc :Lcontinue&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;ln :Lnext&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;ls :Lstep&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;li :Lstepin&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;lo :Lfinish&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;lp :Lprint&amp;lt;CR&amp;gt;
nnoremap &amp;lt;silent&amp;gt; &amp;lt;leader&amp;gt;lv :Lframe variable&amp;lt;CR&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lets have the following source code that we are aiming to debug:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// main.go
package main

import &amp;quot;fmt&amp;quot;

type User struct {
	FirstName string
	LastName  string
}

func (user User) String() string {
	return fmt.Sprintf(&amp;quot;%s %s&amp;quot;, user.FirstName, user.LastName)
}

func main() {
	user := User{
		FirstName: &amp;quot;John&amp;quot;,
		LastName:  &amp;quot;Smith&amp;quot;,
	}

	message := FormatMessage(user, &amp;quot;Golang Weekly Newsletter #756&amp;quot;)

	for index := 0; index &amp;lt; 3; index++ {
		fmt.Printf(&amp;quot;Sending #%d message with %s\n&amp;quot;, index, message)
	}
}

func FormatMessage(user User, message string) string {
	return fmt.Sprintf(&amp;quot;body: %s by %s&amp;quot;, message, user.String())
}

&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Compile the application:
&lt;code&gt;
$ go build -gcflag &#39;-N -l&#39; -o app main.go
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Open the source code:
&lt;code&gt;
$ vim main.go
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Set the &lt;code&gt;LLDB&lt;/code&gt; target to be the compiled binary:
&lt;code&gt;
:Ltarget app
&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Set a breakpoint on desired line by using &lt;code&gt;Lbreakpoint&lt;/code&gt; command or &lt;code&gt;&amp;lt;leader&amp;gt;lb&lt;/code&gt;
shortcut.&lt;/li&gt;
&lt;li&gt;Then you can run the application in debug mode by using &lt;code&gt;Lrun&lt;/code&gt; command or &lt;code&gt;&amp;lt;leader&amp;gt;lr&lt;/code&gt; shortcut.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can watch the illustrates steps in the following video:&lt;/p&gt;

&lt;div class=&#34;embed video-player&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;640&#34; height=&#34;385&#34; src=&#34;http://www.youtube.com/embed/Efk2OImodO0&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;


&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Even though &lt;code&gt;LLDB&lt;/code&gt; is very powerful and commonly used debugger, it does not work properly in the context of &lt;code&gt;Go&lt;/code&gt;.
It crashes sometimes. It made for &lt;code&gt;C\C++&lt;/code&gt; not for &lt;code&gt;Go&lt;/code&gt;.  It cannot follow the execution
flow properly due to the fact that the debugger is not aware about &lt;code&gt;defer&lt;/code&gt; statement.
In addition sometimes &lt;code&gt;go scheduler&lt;/code&gt; changes the context of current executing &lt;code&gt;go routine&lt;/code&gt;.
It changes the stack frame by moving &lt;code&gt;go routine&lt;/code&gt; from one thread to another.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
