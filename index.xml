<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Phogo Labs Journal</title>
    <link>http://blog.phogolabs.com/index.xml</link>
    <language>en-us</language>
    <author>Phogo Labs Ltd.</author>
    <copyright>2016 Phogo Labs Ltd</copyright>
    <updated>Tue, 20 Dec 2016 19:13:53 UTC</updated>
    
    <item>
      <title>Chicago Classical School vs London Mockist School</title>
      <link>http://blog.phogolabs.com/post/tdd-school-types/</link>
      <pubDate>Tue, 20 Dec 2016 19:13:53 UTC</pubDate>
      <author>Houssem El Fekih</author>
      <guid>http://blog.phogolabs.com/post/tdd-school-types/</guid>
      <description>

&lt;p&gt;In the practice of modern TDD two main schools of thoughts among TDD gurus have
emerged.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start by comparing the differing characteristics of each practice and
present the key proponents of each approach.&lt;/p&gt;

&lt;p&gt;As a first oversimplification, we can broadly describe &amp;ldquo;classical TDD&amp;rdquo; as
&amp;ldquo;bottom-up&amp;rdquo; and &amp;ldquo;london mockist&amp;rdquo;  as top-down, as the name suggests mockist
school relies on mock objects (actually doubles but who cares?) to test
interactions on the unit level. Whereas classical school would almost never
rely on mocks but might use some form of fake at the integration level if
needed to simplify or speed up testing (eg. changing API/ slow database).
Actually a unit is any cohesive responsibility or service and in the
&amp;ldquo;classicist&amp;rdquo; view you are encouraged to view a service you&amp;rsquo;re integrating with
as a unit outside your control.&lt;/p&gt;

&lt;p&gt;In order to clear up some of the confusion around the different TDD schools,
let&amp;rsquo;s examine the origin of the terms. The reason why the classical school is
sometimes called chicago is because Kent Beck, author of &amp;ldquo;Test Driven
Development: By Example&amp;rdquo; was based in Chicago and the practice naturally spread
there. The authoritative book for the london school is &amp;ldquo;Growing Object-Oriented
Software, Guided by Tests&amp;rdquo; by Steve Freeman and Nat Pryce. It really doesn&amp;rsquo;t
help that they have similar looking covers and both mention &amp;ldquo;Kent Beck
signature series&amp;rdquo; the book series.  You will find a lot of evangelism and
training around TDD that promotes one idea or the other so don&amp;rsquo;t get bogged
down with terminology and listen to &amp;ldquo;dos and don&amp;rsquo;ts&amp;rdquo; unless they make perfect
sense to you.&lt;/p&gt;

&lt;p&gt;The central schism between the two philosophies is the key focus of each. For
the classical school it is the unit: tests will be state based tests of a class
or unit. these tests will tend to be algorithmic, functional (testing
functionality), state based tests.  When you hear test in this context, it is
valid to imagine an engineer testing if his bicycle design will support a
certain load or if its brakes will work.&lt;/p&gt;

&lt;p&gt;On the other hand, you will find that, curiously, the proponents of the London
school say that TDD is not about &amp;ldquo;testing&amp;rdquo; in the previously mentioned
traditional engineering meaning. Instead TDD would be a lot more about driving
the system and architectural design and hence a design tool for the behaviour
and communication of those classes.&lt;/p&gt;

&lt;p&gt;This key difference shows the biggest strengths and weaknesses respectively, in
the &amp;ldquo;classical school&amp;rdquo; it easy to get bogged out in one class or unit in the
classical school and miss an important detail in integration and have your
classes not work well together. This might mean overall having a bad
architectural design or having to start again more. This happens mostly when
developers do not refactor in the red-green-REFACTOR phase.  However in London
school, since the focus is always on the behaviour between units (interactions)
this problem is avoided.&lt;/p&gt;

&lt;p&gt;However solely focusing on interactions means it is easy to start
over-engineering the design and lose focus of the core-features.  Let&amp;rsquo;s not
forget that when following an evolutionary design, you are limiting yourself.
Ygetou can easily  locked into a limited design weighed heavily by the early
decisions you make.  Another downside to the london school is that it
introduces a lot of baggage as well it makes the cost of refactoring higher
(even just in terms of syntax changes/effort). This is mitigated by the fact
that with the London way it is easy to find opporunities for
&amp;ldquo;micro-refactoring&amp;rdquo; and to be constantly doing it which is encouraged by Nat
Pryce and Steve Freemam.&lt;/p&gt;

&lt;p&gt;Of course you can do architecture or interface refactoring at any time but this
is a little harder and not always obvious in the &amp;ldquo;mockist&amp;rdquo; approach. The london
approach is a layered approach and can introduce a lot of layers. Of course in
any system this can be a  combinatorial explosion of tests, of course we only
do interaction tests on &amp;ldquo;interesting&amp;rdquo; classes and we have to find a sensible
set of tests spanning the total interactions. This still ends up being a lot of
baggage and without spreading the cost of &amp;ldquo;micro-refactoring&amp;rdquo; by constantly
doing it and taking the time for bigger refactoring you can actually end  up
with terrible design, no serious testing value except the acceptance tests and
some interaction tests.&lt;/p&gt;

&lt;p&gt;There is another key difference on the integration level. Integration tests
gain a new responsibility in the &amp;ldquo;classical school&amp;rdquo; because they are your
guaranttree that the pieces fit well together. In my view , this is a more
straightfoward contract and more true to the meaning of a test. Here&amp;rsquo;s my black
box, give it the interesting inputs (with a little gadget on some ends), try to
think up of all the tests that are useful, (reliability, performance, security
etc.). In the the london school you write some acceptance tests for your
walking skelefion that represent a tranche of user-facing functionality, the
minimal possible integration tests possible because otherwise you dillute the
&amp;ldquo;purity&amp;rdquo; of the &amp;ldquo;Test-Driven&amp;rdquo; evolutionary approach to the design.  To its
merit, This is good to give you a measure of progress when you&amp;rsquo;re getting lost
in your sea of interaction/unit tests and allow to do the minimum possible to
satisfy most important constraints which is an important discipline for
startups and entreprise alike.&lt;/p&gt;

&lt;p&gt;At the end of the day what matters is the improvement in the maintainability of
your software and user-value. My personal take is that if you&amp;rsquo;re exploring a
new problem and you are confident of your software engineering skills the
&amp;ldquo;classical&amp;rdquo; school is more natural and will produce better external quality of
software; as long as you remember to refactor carefully. The &amp;ldquo;mockist&amp;rdquo; school
produces, in the hands of good developers, consistently good design, and makes
mediocre developers have an acceptable design but not necessarily high
reliability. It works especially well for pairing and when developers are
trained to do &amp;ldquo;micro-refactoring&amp;rdquo; and interface refactoring (no just API
refactoring but identifying abstractions in the interfaces). Which breaks the
beaten path of your initial evolutionary path and makes your design more
interesting.&lt;/p&gt;

&lt;p&gt;To me , and i hope i am not the only one here, it is still a significant
handicap to the ways of thinking and working of a typical software engineer.
The classical school tries less to intrude on my habits as a software developer
but instead encourages more reliable software. It offers less opinions about
system design so your skills in design can show, which of course is a douible
edged sword.&lt;/p&gt;

&lt;h4 id=&#34;videos&#34;&gt;videos&lt;/h4&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/n62HN2DHDEU&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;hr /&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/8FarI3hpOIE&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;h4 id=&#34;books&#34;&gt;books&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.uk/Growing-Object-Oriented-Software-Guided-Signature/dp/0321503627&#34;&gt;&amp;ldquo;Growing Object-Oriented Software, Guided by Tests&amp;rdquo;&lt;/a&gt; by Steve Freeman and Nat Pryce.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.co.uk/d/cka/Test-Driven-Development-Addison-Wesley-Signature-Kent-Beck/0321146530&#34;&gt;&amp;ldquo;Test Driven Development: By Example&amp;rdquo;&lt;/a&gt; by Kent Beck.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
